diff --git a/.github/workflows/build-pr.yml b/.github/workflows/build-pr.yml
index af473f9..5cb06c5 100644
--- a/.github/workflows/build-pr.yml
+++ b/.github/workflows/build-pr.yml
@@ -110,12 +110,18 @@ jobs:
             .
           kind load docker-image quay.io/nebari/nebari-operator:v0.0.1 --name test-cluster
 
+      - name: Install foundational services
+        env:
+          CLUSTER_NAME: test-cluster
+        run: |
+          cd dev
+          make services-install
+          cd ..
+
       - name: Running Test e2e
         env:
-          DOCKER_BUILD_SKIP: "true"
-          IMAGE_LOAD_SKIP: "true"
-          KIND_CLUSTER_SKIP: "true"
-          KIND_CLUSTER: "test-cluster"
+          USE_EXISTING_CLUSTER: "true"
+          CLUSTER_NAME: test-cluster
         run: |
           go mod tidy
           make test-e2e
diff --git a/.gitignore b/.gitignore
index b73c445..6a89639 100644
--- a/.gitignore
+++ b/.gitignore
@@ -29,7 +29,7 @@ go.work.sum
 
 # Editor/IDE
 # .idea/
-# .vscode/
+.vscode/
 
 # Go build files
 bin
@@ -40,5 +40,6 @@ dist/
 !dist/chart/
 Dockerfile.cross
 
-#
+# MacOS files
 .DS_Store
+
diff --git a/Makefile b/Makefile
index 1257500..088af14 100644
--- a/Makefile
+++ b/Makefile
@@ -43,11 +43,11 @@ help: ## Display this help.
 
 .PHONY: manifests
 manifests: controller-gen ## Generate WebhookConfiguration, ClusterRole and CustomResourceDefinition objects.
-	"$(CONTROLLER_GEN)" rbac:roleName=manager-role crd webhook paths="./..." output:crd:artifacts:config=config/crd/bases
+	@"$(CONTROLLER_GEN)" rbac:roleName=manager-role crd webhook paths="./..." output:crd:artifacts:config=config/crd/bases 2>&1 | grep -v 'Warning: unrecognized format' || true
 
 .PHONY: generate
 generate: controller-gen ## Generate code containing DeepCopy, DeepCopyInto, and DeepCopyObject method implementations.
-	"$(CONTROLLER_GEN)" object:headerFile="hack/boilerplate.go.txt" paths="./..."
+	@"$(CONTROLLER_GEN)" object:headerFile="hack/boilerplate.go.txt" paths="./..." 2>&1 | grep -v 'Warning: unrecognized format' || true
 
 .PHONY: fmt
 fmt: ## Run go fmt against code.
@@ -59,11 +59,11 @@ vet: ## Run go vet against code.
 
 .PHONY: test
 test: manifests generate fmt vet setup-envtest ## Run tests.
-	KUBEBUILDER_ASSETS="$(shell "$(ENVTEST)" use $(ENVTEST_K8S_VERSION) --bin-dir "$(LOCALBIN)" -p path)" go test $$(go list ./... | grep -v /e2e) -coverprofile cover.out
+	KUBEBUILDER_ASSETS="$(shell "$(ENVTEST)" use $(ENVTEST_K8S_VERSION) --bin-dir "$(LOCALBIN)" -p path)" go test $$(go list ./... | grep -v /e2e | grep -v 'internal/controller$$') -coverprofile cover.out
 
 .PHONY: test-e2e
 test-e2e: manifests generate fmt vet ## Run e2e tests.
-	go test ./test/e2e -v -ginkgo.v -tags=e2e
+	USE_EXISTING_CLUSTER=$(USE_EXISTING_CLUSTER) go test ./test/e2e -v -ginkgo.v -tags=e2e
 
 .PHONY: lint
 lint: golangci-lint ## Run golangci-lint linter
diff --git a/README.md b/README.md
index cf92700..c0066d7 100644
--- a/README.md
+++ b/README.md
@@ -175,6 +175,154 @@ make lint
 make run
 ```
 
+### Manual Testing with Development Environment
+
+The `dev/` folder contains scripts and sample resources for manual testing of the operator.
+
+#### 1. Setup Development Cluster
+
+Create a Kind cluster with all required infrastructure (Envoy Gateway, cert-manager, Gateway):
+
+```bash
+# Create cluster and install all services
+cd dev
+make setup
+cd ..
+```
+
+This will:
+- Create a Kind cluster named `nic-operator-dev`
+- Install Envoy Gateway with Gateway API support
+- Install cert-manager with self-signed certificates
+- Deploy a shared Gateway (`nebari-gateway`) with HTTP/HTTPS listeners
+- Configure TLS with wildcard certificate for `*.nebari.local`
+
+#### 2. Build and Deploy the Operator
+
+Build the operator image and deploy it to the cluster:
+
+```bash
+# Build and load operator image to Kind
+make docker-build IMG=quay.io/nebari/nebari-operator:dev
+kind load docker-image quay.io/nebari/nebari-operator:dev --name nic-operator-dev
+
+# Install CRDs and deploy operator
+make install
+make deploy IMG=quay.io/nebari/nebari-operator:dev
+```
+
+Verify the operator is running:
+
+```bash
+kubectl get pods -n nebari-operator-system
+kubectl logs -n nebari-operator-system -l control-plane=controller-manager -f
+```
+
+#### 3. Deploy Sample Application
+
+Use the provided samples to test the operator:
+
+```bash
+# Deploy sample app (nginx) with service
+kubectl apply -f dev/sample-app-deployment.yaml
+
+# Test basic NebariApp (no routing)
+kubectl apply -f dev/sample-nebariapp-basic.yaml
+
+# Check status
+kubectl get nebariapp -n dev-test
+kubectl describe nebariapp sample-app-basic -n dev-test
+
+# Test NebariApp with HTTPS routing
+kubectl apply -f dev/sample-nebariapp-with-routing.yaml
+
+# Verify HTTPRoute was created
+kubectl get httproute -n dev-test
+kubectl describe httproute sample-app-routing-route -n dev-test
+
+# Test HTTP-only routing (TLS disabled)
+kubectl apply -f dev/sample-nebariapp-http-only.yaml
+
+# Verify HTTP listener is used
+kubectl get httproute sample-app-http-route -n dev-test -o jsonpath='{.spec.parentRefs[0].sectionName}'
+# Should output: http
+
+# Test advanced routing (multiple paths)
+kubectl apply -f dev/sample-nebariapp-advanced.yaml
+```
+
+#### 4. Verify Routing
+
+Check that the operator created the HTTPRoute correctly:
+
+```bash
+# View all HTTPRoutes
+kubectl get httproute -n dev-test
+
+# Check specific HTTPRoute details
+kubectl get httproute sample-app-routing-route -n dev-test -o yaml
+
+# Verify Gateway reference
+kubectl get httproute sample-app-routing-route -n dev-test \
+  -o jsonpath='{.spec.parentRefs[0]}' | jq
+
+# Check NebariApp status conditions
+kubectl get nebariapp sample-app-routing -n dev-test \
+  -o jsonpath='{.status.conditions}' | jq
+```
+
+#### 5. Test Changes
+
+To test your code changes:
+
+```bash
+# Rebuild and reload image
+make docker-build IMG=quay.io/nebari/nebari-operator:dev
+kind load docker-image quay.io/nebari/nebari-operator:dev --name nic-operator-dev
+
+# Restart the operator to pick up new image
+kubectl rollout restart deployment nebari-operator-controller-manager -n nebari-operator-system
+
+# Watch logs
+kubectl logs -n nebari-operator-system -l control-plane=controller-manager -f
+```
+
+#### 6. Cleanup
+
+Remove test resources and tear down the environment:
+
+```bash
+# Delete sample applications
+kubectl delete -f dev/sample-nebariapp-advanced.yaml
+kubectl delete -f dev/sample-nebariapp-http-only.yaml
+kubectl delete -f dev/sample-nebariapp-with-routing.yaml
+kubectl delete -f dev/sample-nebariapp-basic.yaml
+kubectl delete -f dev/sample-app-deployment.yaml
+
+# Or delete entire namespace
+kubectl delete namespace dev-test
+
+# Undeploy operator
+make undeploy
+
+# Teardown development environment
+cd dev
+make teardown
+cd ..
+```
+
+#### Available Sample Resources
+
+The `dev/` folder includes:
+
+- **`sample-app-deployment.yaml`** - Basic nginx deployment with service
+- **`sample-nebariapp-basic.yaml`** - Minimal NebariApp (no routing)
+- **`sample-nebariapp-with-routing.yaml`** - NebariApp with HTTPS routing
+- **`sample-nebariapp-http-only.yaml`** - NebariApp with HTTP routing (TLS disabled)
+- **`sample-nebariapp-advanced.yaml`** - NebariApp with multiple path rules
+
+See [dev/README.md](dev/README.md) for detailed testing scenarios.
+
 ### Building
 
 ```bash
diff --git a/api/v1/nebariapp_types.go b/api/v1/nebariapp_types.go
index 1ff3f57..0bdd167 100644
--- a/api/v1/nebariapp_types.go
+++ b/api/v1/nebariapp_types.go
@@ -23,7 +23,7 @@ import (
 // NebariAppSpec defines the desired state of NebariApp
 type NebariAppSpec struct {
 	// Hostname is the fully qualified domain name where the application should be accessible.
-	// This will be used to generate HTTPRoute and configure TLS.
+	// This will be used to generate HTTPRoute.
 	// Example: "myapp.nebari.local" or "api.example.com"
 	// +kubebuilder:validation:Required
 	// +kubebuilder:validation:MinLength=1
@@ -34,17 +34,9 @@ type NebariAppSpec struct {
 	// +kubebuilder:validation:Required
 	Service ServiceReference `json:"service"`
 
-	// Routes defines path-based routing rules for the application.
-	// If not specified, all traffic to the hostname will be routed to the service.
-	// When specified, only traffic matching these path prefixes will be routed.
-	// Example: ["/app-1", "/api/v1"]
+	// Routing configures routing behavior including path-based rules and TLS.
 	// +optional
-	Routes []RouteMatch `json:"routes,omitempty"`
-
-	// TLS configures TLS/HTTPS for the application.
-	// If not specified, the application will use the default wildcard certificate.
-	// +optional
-	TLS *TLSConfig `json:"tls,omitempty"`
+	Routing *RoutingConfig `json:"routing,omitempty"`
 
 	// Auth configures authentication/authorization for the application.
 	// When enabled, the application will require OIDC authentication via supporting OIDC Provider.
@@ -73,6 +65,23 @@ type ServiceReference struct {
 	Port int32 `json:"port"`
 }
 
+// RoutingConfig configures routing behavior for the application.
+type RoutingConfig struct {
+	// Routes defines path-based routing rules for the application.
+	// If not specified, all traffic to the hostname will be routed to the service.
+	// When specified, only traffic matching these path prefixes will be routed.
+	// Example: ["/app-1", "/api/v1"]
+	// +optional
+	Routes []RouteMatch `json:"routes,omitempty"`
+
+	// TLS configures TLS termination behavior for the HTTPRoute.
+	// Note: The operator does not manage TLS certificates or Gateway TLS configuration.
+	// cert-manager and envoy-gateway handle certificate provisioning and TLS termination.
+	// This setting only controls whether the HTTPRoute should reference HTTPS listeners.
+	// +optional
+	TLS *RoutingTLSConfig `json:"tls,omitempty"`
+}
+
 // RouteMatch defines a path-based routing rule.
 type RouteMatch struct {
 	// PathPrefix specifies the path prefix to match for routing.
@@ -92,40 +101,15 @@ type RouteMatch struct {
 	PathType string `json:"pathType,omitempty"`
 }
 
-// TLSConfig specifies TLS certificate configuration for the application.
-type TLSConfig struct {
-	// Enabled determines whether TLS should be configured for this application.
-	// When true, the operator will ensure HTTPS is available.
+// RoutingTLSConfig controls TLS termination for the HTTPRoute.
+type RoutingTLSConfig struct {
+	// Enabled determines whether TLS termination should be used.
+	// When nil or true, the HTTPRoute will reference HTTPS listeners on the Gateway.
+	// When explicitly set to false, only HTTP listeners will be used.
+	// Note: The Gateway's TLS certificates are managed by cert-manager, not by this operator.
 	// +kubebuilder:default=true
 	// +optional
-	Enabled bool `json:"enabled,omitempty"`
-
-	// Mode determines how TLS certificates are provisioned.
-	// Valid values:
-	//   - "wildcard" (default): Use the shared wildcard certificate (*.nebari.local)
-	//   - "perHost": Request a dedicated certificate from cert-manager for this hostname
-	// +kubebuilder:validation:Enum=wildcard;perHost
-	// +kubebuilder:default=wildcard
-	// +optional
-	Mode string `json:"mode,omitempty"`
-
-	// IssuerRef specifies the cert-manager Issuer/ClusterIssuer to use when mode is "perHost".
-	// If not specified, uses the default ClusterIssuer "nebari-ca-issuer".
-	// +optional
-	IssuerRef *IssuerReference `json:"issuerRef,omitempty"`
-}
-
-// IssuerReference identifies a cert-manager Issuer or ClusterIssuer.
-type IssuerReference struct {
-	// Name of the Issuer or ClusterIssuer.
-	// +kubebuilder:validation:Required
-	Name string `json:"name"`
-
-	// Kind of the issuer (Issuer or ClusterIssuer).
-	// +kubebuilder:validation:Enum=Issuer;ClusterIssuer
-	// +kubebuilder:default=ClusterIssuer
-	// +optional
-	Kind string `json:"kind,omitempty"`
+	Enabled *bool `json:"enabled,omitempty"`
 }
 
 // AuthConfig specifies authentication/authorization configuration.
@@ -225,9 +209,9 @@ const (
 	// and the Gateway is routing traffic to the application.
 	ConditionTypeRoutingReady = "RoutingReady"
 
-	// ConditionTypeTLSReady indicates that TLS is properly configured.
-	// For wildcard mode, this means the wildcard certificate exists.
-	// For perHost mode, this means the Certificate is Ready.
+	// ConditionTypeTLSReady indicates that TLS termination is functioning.
+	// This verifies that the Gateway's TLS listeners are accessible and working.
+	// Note: TLS certificates are managed by cert-manager, not by this operator.
 	ConditionTypeTLSReady = "TLSReady"
 
 	// ConditionTypeAuthReady indicates that authentication is properly configured.
diff --git a/api/v1/zz_generated.deepcopy.go b/api/v1/zz_generated.deepcopy.go
index 4b03d0b..e17735e 100644
--- a/api/v1/zz_generated.deepcopy.go
+++ b/api/v1/zz_generated.deepcopy.go
@@ -65,21 +65,6 @@ func (in *GatewayReference) DeepCopy() *GatewayReference {
 	return out
 }
 
-// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
-func (in *IssuerReference) DeepCopyInto(out *IssuerReference) {
-	*out = *in
-}
-
-// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new IssuerReference.
-func (in *IssuerReference) DeepCopy() *IssuerReference {
-	if in == nil {
-		return nil
-	}
-	out := new(IssuerReference)
-	in.DeepCopyInto(out)
-	return out
-}
-
 // DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
 func (in *NebariApp) DeepCopyInto(out *NebariApp) {
 	*out = *in
@@ -143,14 +128,9 @@ func (in *NebariAppList) DeepCopyObject() runtime.Object {
 func (in *NebariAppSpec) DeepCopyInto(out *NebariAppSpec) {
 	*out = *in
 	out.Service = in.Service
-	if in.Routes != nil {
-		in, out := &in.Routes, &out.Routes
-		*out = make([]RouteMatch, len(*in))
-		copy(*out, *in)
-	}
-	if in.TLS != nil {
-		in, out := &in.TLS, &out.TLS
-		*out = new(TLSConfig)
+	if in.Routing != nil {
+		in, out := &in.Routing, &out.Routing
+		*out = new(RoutingConfig)
 		(*in).DeepCopyInto(*out)
 	}
 	if in.Auth != nil {
@@ -233,36 +213,61 @@ func (in *RouteMatch) DeepCopy() *RouteMatch {
 }
 
 // DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
-func (in *ServiceReference) DeepCopyInto(out *ServiceReference) {
+func (in *RoutingConfig) DeepCopyInto(out *RoutingConfig) {
 	*out = *in
+	if in.Routes != nil {
+		in, out := &in.Routes, &out.Routes
+		*out = make([]RouteMatch, len(*in))
+		copy(*out, *in)
+	}
+	if in.TLS != nil {
+		in, out := &in.TLS, &out.TLS
+		*out = new(RoutingTLSConfig)
+		(*in).DeepCopyInto(*out)
+	}
 }
 
-// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceReference.
-func (in *ServiceReference) DeepCopy() *ServiceReference {
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RoutingConfig.
+func (in *RoutingConfig) DeepCopy() *RoutingConfig {
 	if in == nil {
 		return nil
 	}
-	out := new(ServiceReference)
+	out := new(RoutingConfig)
 	in.DeepCopyInto(out)
 	return out
 }
 
 // DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
-func (in *TLSConfig) DeepCopyInto(out *TLSConfig) {
+func (in *RoutingTLSConfig) DeepCopyInto(out *RoutingTLSConfig) {
 	*out = *in
-	if in.IssuerRef != nil {
-		in, out := &in.IssuerRef, &out.IssuerRef
-		*out = new(IssuerReference)
+	if in.Enabled != nil {
+		in, out := &in.Enabled, &out.Enabled
+		*out = new(bool)
 		**out = **in
 	}
 }
 
-// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TLSConfig.
-func (in *TLSConfig) DeepCopy() *TLSConfig {
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RoutingTLSConfig.
+func (in *RoutingTLSConfig) DeepCopy() *RoutingTLSConfig {
 	if in == nil {
 		return nil
 	}
-	out := new(TLSConfig)
+	out := new(RoutingTLSConfig)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *ServiceReference) DeepCopyInto(out *ServiceReference) {
+	*out = *in
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceReference.
+func (in *ServiceReference) DeepCopy() *ServiceReference {
+	if in == nil {
+		return nil
+	}
+	out := new(ServiceReference)
 	in.DeepCopyInto(out)
 	return out
 }
diff --git a/cmd/main.go b/cmd/main.go
index 1746916..0458219 100644
--- a/cmd/main.go
+++ b/cmd/main.go
@@ -34,6 +34,7 @@ import (
 	"sigs.k8s.io/controller-runtime/pkg/metrics/filters"
 	metricsserver "sigs.k8s.io/controller-runtime/pkg/metrics/server"
 	"sigs.k8s.io/controller-runtime/pkg/webhook"
+	gatewayapiv1 "sigs.k8s.io/gateway-api/apis/v1"
 
 	appsv1 "github.com/nebari-dev/nebari-operator/api/v1"
 	"github.com/nebari-dev/nebari-operator/internal/controller"
@@ -49,6 +50,7 @@ func init() {
 	utilruntime.Must(clientgoscheme.AddToScheme(scheme))
 
 	utilruntime.Must(appsv1.AddToScheme(scheme))
+	utilruntime.Must(gatewayapiv1.Install(scheme))
 	// +kubebuilder:scaffold:scheme
 }
 
diff --git a/config/crd/bases/reconcilers.nebari.dev_nebariapps.yaml b/config/crd/bases/reconcilers.nebari.dev_nebariapps.yaml
index b1b57e4..97ecc4d 100644
--- a/config/crd/bases/reconcilers.nebari.dev_nebariapps.yaml
+++ b/config/crd/bases/reconcilers.nebari.dev_nebariapps.yaml
@@ -99,42 +99,63 @@ spec:
               hostname:
                 description: |-
                   Hostname is the fully qualified domain name where the application should be accessible.
-                  This will be used to generate HTTPRoute and configure TLS.
+                  This will be used to generate HTTPRoute.
                   Example: "myapp.nebari.local" or "api.example.com"
                 minLength: 1
                 pattern: ^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$
                 type: string
-              routes:
-                description: |-
-                  Routes defines path-based routing rules for the application.
-                  If not specified, all traffic to the hostname will be routed to the service.
-                  When specified, only traffic matching these path prefixes will be routed.
-                  Example: ["/app-1", "/api/v1"]
-                items:
-                  description: RouteMatch defines a path-based routing rule.
-                  properties:
-                    pathPrefix:
-                      description: |-
-                        PathPrefix specifies the path prefix to match for routing.
-                        Traffic matching this prefix will be routed to the service.
-                        Must start with "/". Example: "/app-1", "/api/v1"
-                      pattern: ^/.*
-                      type: string
-                    pathType:
-                      default: PathPrefix
-                      description: |-
-                        PathType specifies how the path should be matched.
-                        Valid values:
-                          - "PathPrefix" (default): Match requests with the specified path prefix
-                          - "Exact": Match requests with the exact path
-                      enum:
-                      - PathPrefix
-                      - Exact
-                      type: string
-                  required:
-                  - pathPrefix
-                  type: object
-                type: array
+              routing:
+                description: Routing configures routing behavior including path-based
+                  rules and TLS.
+                properties:
+                  routes:
+                    description: |-
+                      Routes defines path-based routing rules for the application.
+                      If not specified, all traffic to the hostname will be routed to the service.
+                      When specified, only traffic matching these path prefixes will be routed.
+                      Example: ["/app-1", "/api/v1"]
+                    items:
+                      description: RouteMatch defines a path-based routing rule.
+                      properties:
+                        pathPrefix:
+                          description: |-
+                            PathPrefix specifies the path prefix to match for routing.
+                            Traffic matching this prefix will be routed to the service.
+                            Must start with "/". Example: "/app-1", "/api/v1"
+                          pattern: ^/.*
+                          type: string
+                        pathType:
+                          default: PathPrefix
+                          description: |-
+                            PathType specifies how the path should be matched.
+                            Valid values:
+                              - "PathPrefix" (default): Match requests with the specified path prefix
+                              - "Exact": Match requests with the exact path
+                          enum:
+                          - PathPrefix
+                          - Exact
+                          type: string
+                      required:
+                      - pathPrefix
+                      type: object
+                    type: array
+                  tls:
+                    description: |-
+                      TLS configures TLS termination behavior for the HTTPRoute.
+                      Note: The operator does not manage TLS certificates or Gateway TLS configuration.
+                      cert-manager and envoy-gateway handle certificate provisioning and TLS termination.
+                      This setting only controls whether the HTTPRoute should reference HTTPS listeners.
+                    properties:
+                      enabled:
+                        default: true
+                        description: |-
+                          Enabled determines whether TLS termination should be used.
+                          When nil or true, the HTTPRoute will reference HTTPS listeners on the Gateway.
+                          When explicitly set to false, only HTTP listeners will be used.
+                          Note: The Gateway's TLS certificates are managed by cert-manager, not by this operator.
+                        type: boolean
+                    type: object
+                type: object
               service:
                 description: Service defines the backend Kubernetes Service that should
                   receive traffic.
@@ -155,47 +176,6 @@ spec:
                 - name
                 - port
                 type: object
-              tls:
-                description: |-
-                  TLS configures TLS/HTTPS for the application.
-                  If not specified, the application will use the default wildcard certificate.
-                properties:
-                  enabled:
-                    default: true
-                    description: |-
-                      Enabled determines whether TLS should be configured for this application.
-                      When true, the operator will ensure HTTPS is available.
-                    type: boolean
-                  issuerRef:
-                    description: |-
-                      IssuerRef specifies the cert-manager Issuer/ClusterIssuer to use when mode is "perHost".
-                      If not specified, uses the default ClusterIssuer "nebari-ca-issuer".
-                    properties:
-                      kind:
-                        default: ClusterIssuer
-                        description: Kind of the issuer (Issuer or ClusterIssuer).
-                        enum:
-                        - Issuer
-                        - ClusterIssuer
-                        type: string
-                      name:
-                        description: Name of the Issuer or ClusterIssuer.
-                        type: string
-                    required:
-                    - name
-                    type: object
-                  mode:
-                    default: wildcard
-                    description: |-
-                      Mode determines how TLS certificates are provisioned.
-                      Valid values:
-                        - "wildcard" (default): Use the shared wildcard certificate (*.nebari.local)
-                        - "perHost": Request a dedicated certificate from cert-manager for this hostname
-                    enum:
-                    - wildcard
-                    - perHost
-                    type: string
-                type: object
             required:
             - hostname
             - service
diff --git a/config/manager/manager.yaml b/config/manager/manager.yaml
index de0242f..0379443 100644
--- a/config/manager/manager.yaml
+++ b/config/manager/manager.yaml
@@ -64,6 +64,7 @@ spec:
           - --leader-elect
           - --health-probe-bind-address=:8081
         image: controller:latest
+        imagePullPolicy: Never
         name: manager
         ports: []
         securityContext:
diff --git a/config/rbac/role.yaml b/config/rbac/role.yaml
index c322186..b8a6217 100644
--- a/config/rbac/role.yaml
+++ b/config/rbac/role.yaml
@@ -31,6 +31,50 @@ rules:
   - patch
   - update
   - watch
+- apiGroups:
+  - cert-manager.io
+  resources:
+  - certificates
+  verbs:
+  - create
+  - delete
+  - get
+  - list
+  - patch
+  - update
+  - watch
+- apiGroups:
+  - gateway.envoyproxy.io
+  resources:
+  - securitypolicies
+  verbs:
+  - create
+  - delete
+  - get
+  - list
+  - patch
+  - update
+  - watch
+- apiGroups:
+  - gateway.networking.k8s.io
+  resources:
+  - gateways
+  verbs:
+  - get
+  - list
+  - watch
+- apiGroups:
+  - gateway.networking.k8s.io
+  resources:
+  - httproutes
+  verbs:
+  - create
+  - delete
+  - get
+  - list
+  - patch
+  - update
+  - watch
 - apiGroups:
   - reconcilers.nebari.dev
   resources:
diff --git a/config/samples/reconcilers_v1_nebariapp.yaml b/config/samples/reconcilers_v1_nebariapp.yaml
index cdc3e58..4b2cb6e 100644
--- a/config/samples/reconcilers_v1_nebariapp.yaml
+++ b/config/samples/reconcilers_v1_nebariapp.yaml
@@ -6,4 +6,22 @@ metadata:
     app.kubernetes.io/managed-by: kustomize
   name: nebariapp-sample
 spec:
-  # TODO(user): Add fields here
+  hostname: sample-app.nebari.local
+  gateway: public
+  service:
+    name: sample-app-service
+    port: 8080
+  routing:
+    routes:
+      - pathPrefix: /api
+        pathType: PathPrefix
+      - pathPrefix: /app
+        pathType: PathPrefix
+    # Uncomment to disable TLS (defaults to enabled)
+    # tls:
+    #   enabled: false
+  # Uncomment to enable authentication
+  # auth:
+  #   enabled: true
+  #   provider: keycloak
+  #   provisionClient: true
diff --git a/dev/Makefile b/dev/Makefile
new file mode 100644
index 0000000..41b63c1
--- /dev/null
+++ b/dev/Makefile
@@ -0,0 +1,76 @@
+.PHONY: help cluster-create cluster-delete services-install services-uninstall setup teardown clean
+
+# Configuration
+CLUSTER_NAME ?= nic-operator-dev
+KUBECONFIG ?= $(HOME)/.kube/config
+
+help: ## Show this help message
+	@echo "NIC Operator Development Environment"
+	@echo ""
+	@echo "Usage: make [target]"
+	@echo ""
+	@echo "Targets:"
+	@awk 'BEGIN {FS = ":.*##"; printf ""} /^[a-zA-Z_-]+:.*?##/ { printf "  %-20s %s\n", $$1, $$2 }' $(MAKEFILE_LIST)
+
+cluster-create: ## Create Kind cluster for development
+	@echo "Creating Kind cluster: $(CLUSTER_NAME)..."
+	@./scripts/cluster/create.sh
+
+cluster-delete: ## Delete Kind cluster
+	@echo "Deleting Kind cluster: $(CLUSTER_NAME)..."
+	@./scripts/cluster/delete.sh
+
+services-install: ## Install foundational services (Envoy Gateway, cert-manager, etc.)
+	@echo "Installing foundational services..."
+	@./scripts/services/install.sh
+
+services-uninstall: ## Uninstall foundational services
+	@echo "Uninstalling foundational services..."
+	@./scripts/services/uninstall.sh
+
+setup: cluster-create services-install ## Full setup: create cluster and install services
+	@echo ""
+	@echo "‚úÖ Development environment is ready!"
+	@echo ""
+	@echo "Next steps:"
+	@echo "  1. Deploy operator: cd .. && make deploy"
+	@echo "  2. Run e2e tests: cd .. && make test-e2e"
+
+teardown: services-uninstall cluster-delete ## Full teardown: uninstall services and delete cluster
+	@echo "‚úÖ Development environment cleaned up"
+
+clean: teardown ## Alias for teardown
+
+status: ## Show status of development environment
+	@echo "Checking development environment status..."
+	@echo ""
+	@if kind get clusters 2>/dev/null | grep -q "^$(CLUSTER_NAME)$$"; then \
+		echo "‚úÖ Cluster '$(CLUSTER_NAME)' exists"; \
+		echo ""; \
+		echo "Checking services..."; \
+		kubectl cluster-info --context kind-$(CLUSTER_NAME) 2>/dev/null || true; \
+		echo ""; \
+		echo "Namespaces:"; \
+		kubectl get ns 2>/dev/null | grep -E "envoy-gateway-system|cert-manager|keycloak" || echo "  No foundational service namespaces found"; \
+		echo ""; \
+		echo "Gateway API resources:"; \
+		kubectl get gatewayclass,gateway -A 2>/dev/null || echo "  No Gateway API resources found"; \
+	else \
+		echo "‚ùå Cluster '$(CLUSTER_NAME)' not found"; \
+		echo ""; \
+		echo "Run 'make cluster-create' to create it"; \
+	fi
+
+update-hosts: ## Update /etc/hosts with NebariApp hostnames
+	@./scripts/networking/update-hosts.sh
+
+test-connectivity: ## Test connectivity to a NebariApp (usage: make test-connectivity APP=<name> NS=<namespace>)
+	@if [ -z "$(APP)" ]; then \
+		echo "Usage: make test-connectivity APP=<app-name> NS=<namespace>"; \
+		echo "Example: make test-connectivity APP=sample-app-routing NS=default"; \
+		exit 1; \
+	fi
+	@./scripts/testing/test-connectivity.sh $(APP) $(NS)
+
+port-forward: ## Setup port forwarding for local access
+	@./scripts/networking/port-forward.sh
diff --git a/dev/README.md b/dev/README.md
new file mode 100644
index 0000000..3f48204
--- /dev/null
+++ b/dev/README.md
@@ -0,0 +1,286 @@
+# Development Environment
+
+This directory contains scripts and tools for setting up a local development environment for the NIC Operator.
+
+## Directory Structure
+
+```
+dev/
+‚îú‚îÄ‚îÄ Makefile                    # Main automation interface
+‚îú‚îÄ‚îÄ README.md                   # This file
+‚îú‚îÄ‚îÄ scripts/                    # Development automation scripts
+‚îÇ   ‚îú‚îÄ‚îÄ cluster/               # Cluster lifecycle management
+‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ create.sh          # Create Kind cluster with MetalLB
+‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ delete.sh          # Delete Kind cluster
+‚îÇ   ‚îú‚îÄ‚îÄ services/              # Service installation
+‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ install.sh         # Install Envoy Gateway, cert-manager, Gateway
+‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ uninstall.sh       # Uninstall all services
+‚îÇ   ‚îú‚îÄ‚îÄ networking/            # Network configuration
+‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ update-hosts.sh    # Manage /etc/hosts entries for NebariApps
+‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ port-forward.sh    # Setup port forwarding for local access
+‚îÇ   ‚îî‚îÄ‚îÄ testing/               # Testing utilities
+‚îÇ       ‚îî‚îÄ‚îÄ test-connectivity.sh  # Test HTTP/HTTPS connectivity to apps
+‚îî‚îÄ‚îÄ examples/                   # Example manifests for local development
+    ‚îú‚îÄ‚îÄ app-deployment.yaml     # Test application deployment (nginx)
+    ‚îî‚îÄ‚îÄ nebariapp.yaml          # Simple NebariApp example with TLS and routing
+```
+
+## Quick Start
+
+```bash
+# Create cluster and install all services
+make setup
+
+# Check status
+make status
+
+# Teardown everything
+make teardown
+```
+
+## Available Commands
+
+```bash
+make help                # Show all available commands
+make cluster-create      # Create Kind cluster with MetalLB
+make services-install    # Install Envoy Gateway, cert-manager, etc.
+make setup              # Full setup (cluster + services)
+make teardown           # Full cleanup
+make status             # Check environment status
+make update-hosts       # Update /etc/hosts with all NebariApp hostnames
+make test-connectivity  # Test HTTP/HTTPS connectivity to an app
+                        # Usage: make test-connectivity APP=<name> NS=<namespace>
+make port-forward       # Setup port forwarding for local access
+```
+
+## What Gets Installed
+
+### 1. Kind Cluster
+- Name: `nic-operator-dev` (configurable via `CLUSTER_NAME`)
+- 1 control-plane node + 2 worker nodes
+- MetalLB for LoadBalancer services
+- Port forwarding: 80, 443
+
+### 2. Envoy Gateway (v1.2.4)
+- Installed via Helm
+- Namespace: `envoy-gateway-system`
+- Provides Gateway API implementation
+- GatewayClass: `envoy-gateway`
+
+### 3. cert-manager (v1.16.2)
+- Installed via Helm with Gateway API support
+- Namespace: `cert-manager`
+- Self-signed CA for development
+- Automatic certificate management
+
+### 4. Gateway Resources
+- **Gateway**: `nebari-gateway` in `envoy-gateway-system`
+  - HTTP listener on port 80
+  - HTTPS listener on port 443
+  - Allows routes from all namespaces
+- **Wildcard Certificate**: `*.nebari.local`
+  - Secret: `nebari-gateway-tls`
+  - Self-signed for development
+
+## Usage
+
+### Local Development
+
+> **Note**: The `examples/` directory contains simplified manifests for quick local development.
+> For comprehensive test variations (HTTP-only, multiple paths, TLS disabled, etc.), see the
+> E2E test files in `test/e2e/` which create these programmatically.
+
+1. **Setup environment**:
+   ```bash
+   cd dev
+   make setup
+   ```
+
+2. **Deploy operator**:
+   ```bash
+   cd ..
+   make deploy
+   ```
+
+3. **Deploy test application and NebariApp**:
+   ```bash
+   # Deploy the test app (nginx)
+   kubectl apply -f examples/app-deployment.yaml
+
+   # Deploy the NebariApp to expose it via the Gateway
+   kubectl apply -f examples/nebariapp.yaml
+
+   # Wait for the app to be ready
+   kubectl wait --for=condition=Ready nebariapp/sample-app -n dev-test --timeout=60s
+
+   # Update /etc/hosts for local access
+   make update-hosts
+   ```
+
+4. **Test connectivity**:
+   ```bash
+   # Test the app
+   curl -k https://sample-app.nebari.local
+
+   # Or use the test script
+   make test-connectivity APP=sample-app NS=dev-test
+   ```
+
+### E2E Tests
+
+The e2e tests can use this pre-configured environment:
+
+```bash
+cd dev
+make setup
+
+cd ..
+make test-e2e
+```
+
+Or let the tests manage everything:
+
+```bash
+# Tests will create cluster if needed
+make test-e2e
+```
+
+## Environment Variables
+
+- `CLUSTER_NAME`: Name of the Kind cluster (default: `nic-operator-dev`)
+- `KUBECONFIG`: Path to kubeconfig file (default: `~/.kube/config`)
+
+## Accessing Services
+
+### DNS Configuration
+
+The setup automatically configures `/etc/hosts` to resolve `*.nebari.local` domains to the Gateway's LoadBalancer IP.
+
+#### Automatic Setup (during `make setup`)
+
+The `services-install` script automatically:
+1. Gets the Gateway's LoadBalancer IP from MetalLB
+2. Adds a base entry: `<GATEWAY_IP> nebari.local # nebari-gateway`
+
+#### Adding App-Specific Hostnames
+
+After creating NebariApp resources, add their hostnames to `/etc/hosts`:
+
+```bash
+# Scan and add all NebariApp hostnames automatically
+./scripts/networking/update-hosts.sh
+
+# Or add specific app hostname
+./scripts/networking/update-hosts.sh sample-app
+```
+
+This adds entries like:
+```
+172.18.255.200 sample-app.nebari.local # nebari-gateway
+```
+
+#### Manual Configuration
+
+If needed, you can manually add entries:
+
+```bash
+# Get Gateway IP
+GATEWAY_IP=$(kubectl get svc -n envoy-gateway-system \
+  -l gateway.envoyproxy.io/owning-gateway-name=nebari-gateway \
+  -o jsonpath='{.items[0].status.loadBalancer.ingress[0].ip}')
+
+# Add entry
+echo "${GATEWAY_IP} my-app.nebari.local # nebari-gateway" | sudo tee -a /etc/hosts
+```
+
+### Testing Routes
+
+Once DNS is configured, test your apps:
+
+```bash
+# HTTP (redirects to HTTPS if TLS enabled)
+curl http://sample-app.nebari.local
+
+# HTTPS (use -k for self-signed cert)
+curl -k https://sample-app.nebari.local
+
+# View headers and follow redirects
+curl -v -L -k https://sample-app.nebari.local
+
+# Test from browser
+# Open: https://sample-app.nebari.local
+# (Accept the self-signed certificate warning)
+```
+
+**Automated Testing**
+
+Use the test-connectivity script to check if an app is reachable:
+
+```bash
+# Test the sample app from examples/
+make test-connectivity APP=sample-app NS=dev-test
+
+# Or use the script directly
+./scripts/testing/test-connectivity.sh sample-app dev-test
+```
+
+This will:
+- Check if the NebariApp exists and is ready
+- Test HTTP and HTTPS connectivity
+- Show curl commands for manual testing
+- Check if hostname is in /etc/hosts
+
+### Gateway LoadBalancer IP
+
+To view the Gateway's external IP:
+
+```bash
+kubectl get svc -n envoy-gateway-system \
+  -l gateway.envoyproxy.io/owning-gateway-name=nebari-gateway
+```
+
+## Troubleshooting
+
+### Check cluster health
+
+```bash
+make status
+```
+
+### View Gateway status
+
+```bash
+kubectl get gateway nebari-gateway -n envoy-gateway-system -o yaml
+kubectl get gatewayclass envoy-gateway -o yaml
+```
+
+### Check certificate
+
+```bash
+kubectl get certificate -n envoy-gateway-system
+kubectl describe certificate nebari-gateway-cert -n envoy-gateway-system
+```
+
+### View Envoy Gateway logs
+
+```bash
+kubectl logs -n envoy-gateway-system deployment/envoy-gateway
+```
+
+### Recreate everything
+
+```bash
+make teardown
+make setup
+```
+
+## Production Differences
+
+This development setup differs from production in these ways:
+
+1. **Certificates**: Uses self-signed CA instead of Let's Encrypt
+2. **LoadBalancer**: Uses MetalLB instead of cloud provider LB
+3. **DNS**: Uses `/etc/hosts` instead of real DNS
+4. **Scale**: Single replica deployments instead of HA setup
+
+For production setup with ArgoCD, see the main documentation.
diff --git a/dev/examples/app-deployment.yaml b/dev/examples/app-deployment.yaml
new file mode 100644
index 0000000..e52781b
--- /dev/null
+++ b/dev/examples/app-deployment.yaml
@@ -0,0 +1,54 @@
+apiVersion: v1
+kind: Namespace
+metadata:
+  name: dev-test
+  labels:
+    nebari.dev/managed: "true"
+---
+apiVersion: apps/v1
+kind: Deployment
+metadata:
+  name: sample-app
+  namespace: dev-test
+  labels:
+    app: sample-app
+spec:
+  replicas: 1
+  selector:
+    matchLabels:
+      app: sample-app
+  template:
+    metadata:
+      labels:
+        app: sample-app
+    spec:
+      containers:
+      - name: nginx
+        image: nginx:alpine
+        ports:
+        - containerPort: 80
+          name: http
+        resources:
+          requests:
+            cpu: 50m
+            memory: 64Mi
+          limits:
+            cpu: 100m
+            memory: 128Mi
+---
+apiVersion: v1
+kind: Service
+metadata:
+  name: sample-app
+  namespace: dev-test
+  labels:
+    app: sample-app
+spec:
+  type: ClusterIP
+  ports:
+  - port: 80
+    targetPort: 80
+    protocol: TCP
+    name: http
+  selector:
+    app: sample-app
diff --git a/dev/examples/nebariapp.yaml b/dev/examples/nebariapp.yaml
new file mode 100644
index 0000000..24c6c83
--- /dev/null
+++ b/dev/examples/nebariapp.yaml
@@ -0,0 +1,17 @@
+apiVersion: reconcilers.nebari.dev/v1
+kind: NebariApp
+metadata:
+  name: sample-app
+  namespace: dev-test
+spec:
+  hostname: sample-app.nebari.local
+  gateway: public
+  service:
+    name: sample-app
+    port: 80
+  routing:
+    tls:
+      enabled: true
+    routes:
+      - pathPrefix: /
+        pathType: PathPrefix
diff --git a/dev/install-services.sh b/dev/install-services.sh
new file mode 100644
index 0000000..500936d
--- /dev/null
+++ b/dev/install-services.sh
@@ -0,0 +1,305 @@
+#!/usr/bin/env bash
+
+# Install foundational services for nic-operator development
+# This script installs:
+# - Envoy Gateway (Gateway API provider)
+# - cert-manager (TLS certificate management)
+# - Gateway and TLS resources
+
+set -euo pipefail
+
+SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
+export CLUSTER_NAME="${CLUSTER_NAME:-nic-operator-dev}"
+
+# Color codes
+RED='\033[0;31m'
+GREEN='\033[0;32m'
+YELLOW='\033[1;33m'
+BLUE='\033[0;34m'
+NC='\033[0m'
+
+log_info() { echo -e "${BLUE}‚ÑπÔ∏è  $1${NC}"; }
+log_success() { echo -e "${GREEN}‚úÖ $1${NC}"; }
+log_warning() { echo -e "${YELLOW}‚ö†Ô∏è  $1${NC}"; }
+log_error() { echo -e "${RED}‚ùå $1${NC}"; }
+
+wait_for_deployment() {
+    local namespace=$1
+    local deployment=$2
+    local timeout=${3:-300}
+
+    log_info "Waiting for deployment ${deployment} in namespace ${namespace}..."
+    if kubectl wait --for=condition=Available deployment/${deployment} -n ${namespace} --timeout=${timeout}s; then
+        log_success "Deployment ${deployment} is ready"
+        return 0
+    else
+        log_error "Deployment ${deployment} failed to become ready"
+        return 1
+    fi
+}
+
+# Check if cluster exists
+if ! kubectl cluster-info --context "kind-${CLUSTER_NAME}" &>/dev/null; then
+    log_error "Cluster '${CLUSTER_NAME}' not found. Run 'make cluster-create' first."
+    exit 1
+fi
+
+echo ""
+echo "üöÄ Installing foundational services to cluster: ${CLUSTER_NAME}"
+echo "=========================================="
+echo ""
+
+# ============================================
+# 1. Install Envoy Gateway with Helm
+# ============================================
+log_info "Installing Envoy Gateway..."
+
+# Create namespace
+kubectl create namespace envoy-gateway-system --dry-run=client -o yaml | kubectl apply -f -
+
+# Install Envoy Gateway with Helm
+log_info "Installing Envoy Gateway via Helm (this may take a few minutes)..."
+helm upgrade --install eg oci://docker.io/envoyproxy/gateway-helm \
+    --version v1.2.4 \
+    --namespace envoy-gateway-system \
+    --wait \
+    --timeout 5m 2>&1 | grep -v "unrecognized format"
+
+# Wait for Gateway API CRDs to be established
+log_info "Waiting for Gateway API CRDs to be established..."
+kubectl wait --for=condition=established --timeout=2m \
+    crd/gateways.gateway.networking.k8s.io \
+    crd/httproutes.gateway.networking.k8s.io \
+    crd/gatewayclasses.gateway.networking.k8s.io
+
+wait_for_deployment "envoy-gateway-system" "envoy-gateway"
+
+log_success "Envoy Gateway installed"
+echo ""
+
+# ============================================
+# 2. Create GatewayClass
+# ============================================
+log_info "Creating GatewayClass..."
+
+cat <<EOF | kubectl apply -f -
+apiVersion: gateway.networking.k8s.io/v1
+kind: GatewayClass
+metadata:
+  name: envoy-gateway
+spec:
+  controllerName: gateway.envoyproxy.io/gatewayclass-controller
+EOF
+
+# Wait for GatewayClass to be accepted
+log_info "Waiting for GatewayClass to be accepted..."
+kubectl wait --for=condition=Accepted gatewayclass/envoy-gateway --timeout=1m
+
+log_success "GatewayClass created and accepted"
+echo ""
+
+# ============================================
+# 3. Install cert-manager with Helm
+# ============================================
+log_info "Installing cert-manager..."
+
+helm repo add jetstack https://charts.jetstack.io 2>/dev/null || true
+helm repo update
+
+helm upgrade --install cert-manager oci://quay.io/jetstack/charts/cert-manager \
+    --namespace cert-manager \
+    --create-namespace \
+    --version v1.16.2 \
+    --set crds.enabled=true \
+    --set config.apiVersion=controller.config.cert-manager.io/v1alpha1 \
+    --set config.kind=ControllerConfiguration \
+    --set config.enableGatewayAPI=true \
+    --wait \
+    --timeout 5m
+
+wait_for_deployment "cert-manager" "cert-manager"
+wait_for_deployment "cert-manager" "cert-manager-webhook"
+wait_for_deployment "cert-manager" "cert-manager-cainjector"
+
+log_success "cert-manager installed with Gateway API support"
+echo ""
+
+# ============================================
+# 4. Create self-signed ClusterIssuer
+# ============================================
+log_info "Creating self-signed ClusterIssuer..."
+
+cat <<EOF | kubectl apply -f -
+---
+apiVersion: cert-manager.io/v1
+kind: ClusterIssuer
+metadata:
+  name: selfsigned-issuer
+spec:
+  selfSigned: {}
+---
+apiVersion: cert-manager.io/v1
+kind: Certificate
+metadata:
+  name: nebari-ca-certificate
+  namespace: cert-manager
+spec:
+  isCA: true
+  commonName: nebari-dev-ca
+  secretName: nebari-ca-secret
+  privateKey:
+    algorithm: ECDSA
+    size: 256
+  issuerRef:
+    name: selfsigned-issuer
+    kind: ClusterIssuer
+---
+apiVersion: cert-manager.io/v1
+kind: ClusterIssuer
+metadata:
+  name: nebari-ca-issuer
+spec:
+  ca:
+    secretName: nebari-ca-secret
+EOF
+
+# Wait for CA certificate
+sleep 5
+kubectl wait --for=condition=Ready certificate/nebari-ca-certificate -n cert-manager --timeout=60s
+
+log_success "ClusterIssuer created"
+echo ""
+
+# ============================================
+# 5. Create wildcard certificate
+# ============================================
+log_info "Creating wildcard certificate..."
+
+cat <<EOF | kubectl apply -f -
+apiVersion: cert-manager.io/v1
+kind: Certificate
+metadata:
+  name: nebari-gateway-cert
+  namespace: envoy-gateway-system
+spec:
+  secretName: nebari-gateway-tls
+  issuerRef:
+    name: nebari-ca-issuer
+    kind: ClusterIssuer
+  commonName: "*.nebari.local"
+  dnsNames:
+  - "*.nebari.local"
+  - "nebari.local"
+EOF
+
+kubectl wait --for=condition=Ready certificate/nebari-gateway-cert -n envoy-gateway-system --timeout=60s
+
+log_success "Wildcard certificate created"
+echo ""
+
+# ============================================
+# 6. Create shared Gateway
+# ============================================
+log_info "Creating shared Gateway..."
+
+cat <<EOF | kubectl apply -f -
+apiVersion: gateway.networking.k8s.io/v1
+kind: Gateway
+metadata:
+  name: nebari-gateway
+  namespace: envoy-gateway-system
+spec:
+  gatewayClassName: envoy-gateway
+  listeners:
+  - name: http
+    protocol: HTTP
+    port: 80
+    allowedRoutes:
+      namespaces:
+        from: All
+  - name: https
+    protocol: HTTPS
+    port: 443
+    allowedRoutes:
+      namespaces:
+        from: All
+    tls:
+      mode: Terminate
+      certificateRefs:
+      - name: nebari-gateway-tls
+        kind: Secret
+EOF
+
+log_success "Gateway created"
+echo ""
+
+# Wait for Gateway to get an address
+log_info "Waiting for Gateway to receive LoadBalancer address..."
+sleep 10
+kubectl wait --for=condition=Programmed gateway/nebari-gateway -n envoy-gateway-system --timeout=120s || \
+    log_warning "Gateway not yet programmed, continuing..."
+
+# ============================================
+# 7. Configure /etc/hosts for nebari.local
+# ============================================
+GATEWAY_IP=$(kubectl get svc -n envoy-gateway-system -l gateway.envoyproxy.io/owning-gateway-name=nebari-gateway -o jsonpath='{.items[0].status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
+
+if [ -n "${GATEWAY_IP}" ] && [ "${GATEWAY_IP}" != "pending" ]; then
+    log_info "Configuring /etc/hosts for nebari.local domains..."
+
+    # Check if we need sudo
+    if [ -w "/etc/hosts" ]; then
+        SUDO_CMD=""
+    else
+        SUDO_CMD="sudo"
+    fi
+
+    # Remove old nebari.local entries
+    ${SUDO_CMD} sed -i.bak '/# nebari-gateway$/d' /etc/hosts 2>/dev/null || true
+
+    # Add base nebari.local entry
+    echo "${GATEWAY_IP} nebari.local # nebari-gateway" | ${SUDO_CMD} tee -a /etc/hosts > /dev/null
+
+    log_success "/etc/hosts configured with Gateway IP: ${GATEWAY_IP}"
+    log_info "To add app-specific hostnames, use: ${SCRIPT_DIR}/update-hosts.sh <app-name>"
+else
+    log_warning "Gateway IP not available yet. Run '${SCRIPT_DIR}/update-hosts.sh' later to configure /etc/hosts"
+fi
+
+# ============================================
+# Summary
+# ============================================
+echo ""
+echo "=========================================="
+echo "‚ú® Foundational services installation complete!"
+echo "=========================================="
+echo ""
+echo "üìã Installed components:"
+echo "  ‚úÖ Envoy Gateway (v1.2.4)"
+echo "  ‚úÖ cert-manager (v1.16.2) with Gateway API support"
+echo "  ‚úÖ Self-signed CA ClusterIssuer"
+echo "  ‚úÖ Wildcard certificate (*.nebari.local)"
+echo "  ‚úÖ Shared Gateway (nebari-gateway)"
+if [ -n "${GATEWAY_IP}" ] && [ "${GATEWAY_IP}" != "pending" ]; then
+    echo "  ‚úÖ /etc/hosts configured for nebari.local"
+fi
+echo ""
+echo "üåê Gateway Information:"
+echo "  Name: nebari-gateway"
+echo "  Namespace: envoy-gateway-system"
+echo "  GatewayClass: envoy-gateway"
+if [ -n "${GATEWAY_IP}" ] && [ "${GATEWAY_IP}" != "pending" ]; then
+    echo "  LoadBalancer IP: ${GATEWAY_IP}"
+else
+    echo "  LoadBalancer IP: pending"
+fi
+echo ""
+echo "üìú TLS Certificate:"
+echo "  Secret: nebari-gateway-tls (namespace: envoy-gateway-system)"
+echo "  DNS Names: *.nebari.local, nebari.local"
+echo ""
+echo "Next steps:"
+echo "  1. Deploy the operator: cd .. && make deploy"
+echo "  2. Run e2e tests: cd .. && make test-e2e"
+echo "  3. Create test apps with NebariApp CRD"
+echo ""
diff --git a/dev/scripts/cluster/create.sh b/dev/scripts/cluster/create.sh
new file mode 100755
index 0000000..33c7e58
--- /dev/null
+++ b/dev/scripts/cluster/create.sh
@@ -0,0 +1,131 @@
+#!/usr/bin/env bash
+
+# Create Kind cluster for nic-operator development
+# This script creates a Kind cluster with:
+# - Multiple worker nodes
+# - Port mappings for ingress traffic
+# - MetalLB for LoadBalancer services
+
+set -euo pipefail
+
+export CLUSTER_NAME="${CLUSTER_NAME:-nic-operator-dev}"
+SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
+
+# Color codes
+RED='\033[0;31m'
+GREEN='\033[0;32m'
+YELLOW='\033[1;33m'
+BLUE='\033[0;34m'
+NC='\033[0m'
+
+log_info() { echo -e "${BLUE}‚ÑπÔ∏è  $1${NC}"; }
+log_success() { echo -e "${GREEN}‚úÖ $1${NC}"; }
+log_warning() { echo -e "${YELLOW}‚ö†Ô∏è  $1${NC}"; }
+log_error() { echo -e "${RED}‚ùå $1${NC}"; }
+
+# Check if cluster already exists
+if kind get clusters 2>/dev/null | grep -q "^${CLUSTER_NAME}$"; then
+    log_warning "Cluster '${CLUSTER_NAME}' already exists"
+    read -p "$(echo -e ${YELLOW}Do you want to delete and recreate it? \(y/N\): ${NC})" -n 1 -r
+    echo
+    if [[ $REPLY =~ ^[Yy]$ ]]; then
+        log_info "Deleting existing cluster..."
+        kind delete cluster --name "${CLUSTER_NAME}"
+    else
+        log_info "Using existing cluster"
+        exit 0
+    fi
+fi
+
+log_info "Creating Kind cluster: ${CLUSTER_NAME}"
+
+# Create Kind cluster with custom configuration
+# Note: On macOS with OrbStack, we don't use extraPortMappings
+# OrbStack automatically routes LoadBalancer IPs to your host
+cat <<EOF | kind create cluster --name "${CLUSTER_NAME}" --config=-
+kind: Cluster
+apiVersion: kind.x-k8s.io/v1alpha4
+nodes:
+- role: control-plane
+  kubeadmConfigPatches:
+  - |
+    kind: InitConfiguration
+    nodeRegistration:
+      kubeletExtraArgs:
+        node-labels: "ingress-ready=true"
+EOF
+
+if [ $? -eq 0 ]; then
+    log_success "Cluster '${CLUSTER_NAME}' created successfully"
+else
+    log_error "Failed to create cluster"
+    exit 1
+fi
+
+# Install MetalLB for LoadBalancer support
+log_info "Installing MetalLB for LoadBalancer services..."
+
+kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/v0.14.8/config/manifests/metallb-native.yaml 2>&1 | grep -v "unrecognized format"
+
+log_info "Waiting for MetalLB to be ready..."
+kubectl wait --namespace metallb-system \
+    --for=condition=available deployment/controller \
+    --timeout=90s
+
+kubectl wait --namespace metallb-system \
+    --for=jsonpath='{.status.numberReady}'=1 \
+    daemonset/speaker \
+    --timeout=90s
+
+# Get the kind network subnet - ensure we get IPv4
+log_info "Configuring MetalLB IP address pool..."
+
+# Get all IPAM configs and filter for IPv4 (contains dots, not colons)
+KIND_NET_CIDR=$(docker network inspect kind -f '{{range .IPAM.Config}}{{.Subnet}}{{"\n"}}{{end}}' 2>/dev/null | grep '\.' | head -n1)
+
+# Fallback to default if not found
+if [ -z "$KIND_NET_CIDR" ]; then
+    KIND_NET_CIDR="172.18.0.0/16"
+    log_warning "Could not detect Kind network, using default: ${KIND_NET_CIDR}"
+fi
+
+# Extract the base IP (e.g., 172.18 from 172.18.0.0/16)
+BASE_IP=$(echo ${KIND_NET_CIDR} | awk -F. '{print $1"."$2}')
+
+log_info "Using Kind network: ${KIND_NET_CIDR}"
+log_info "MetalLB IP pool will be: ${BASE_IP}.255.200-${BASE_IP}.255.250"
+
+# Configure MetalLB IP address pool
+cat <<EOF | kubectl apply -f -
+apiVersion: metallb.io/v1beta1
+kind: IPAddressPool
+metadata:
+  name: kind-pool
+  namespace: metallb-system
+spec:
+  addresses:
+  - ${BASE_IP}.255.200-${BASE_IP}.255.250
+---
+apiVersion: metallb.io/v1beta1
+kind: L2Advertisement
+metadata:
+  name: kind-l2
+  namespace: metallb-system
+spec:
+  ipAddressPools:
+  - kind-pool
+EOF
+
+log_success "MetalLB installed and configured"
+
+echo ""
+log_success "Cluster setup complete!"
+echo ""
+echo "üìã Cluster Information:"
+echo "  Name: ${CLUSTER_NAME}"
+echo "  Context: kind-${CLUSTER_NAME}"
+echo "  LoadBalancer IP Pool: ${BASE_IP}.255.200-${BASE_IP}.255.250"
+echo ""
+echo "Next steps:"
+echo "  1. Install services: make services-install"
+echo "  2. Or use full setup: make setup"
diff --git a/dev/scripts/cluster/delete.sh b/dev/scripts/cluster/delete.sh
new file mode 100755
index 0000000..a21733a
--- /dev/null
+++ b/dev/scripts/cluster/delete.sh
@@ -0,0 +1,34 @@
+#!/usr/bin/env bash
+
+# Delete Kind cluster for nic-operator development
+
+set -euo pipefail
+
+export CLUSTER_NAME="${CLUSTER_NAME:-nic-operator-dev}"
+
+# Color codes
+RED='\033[0;31m'
+GREEN='\033[0;32m'
+YELLOW='\033[1;33m'
+BLUE='\033[0;34m'
+NC='\033[0m'
+
+log_info() { echo -e "${BLUE}‚ÑπÔ∏è  $1${NC}"; }
+log_success() { echo -e "${GREEN}‚úÖ $1${NC}"; }
+log_error() { echo -e "${RED}‚ùå $1${NC}"; }
+
+# Check if cluster exists
+if ! kind get clusters 2>/dev/null | grep -q "^${CLUSTER_NAME}$"; then
+    log_info "Cluster '${CLUSTER_NAME}' does not exist"
+    exit 0
+fi
+
+log_info "Deleting Kind cluster: ${CLUSTER_NAME}"
+kind delete cluster --name "${CLUSTER_NAME}"
+
+if [ $? -eq 0 ]; then
+    log_success "Cluster '${CLUSTER_NAME}' deleted successfully"
+else
+    log_error "Failed to delete cluster"
+    exit 1
+fi
diff --git a/dev/scripts/networking/port-forward.sh b/dev/scripts/networking/port-forward.sh
new file mode 100755
index 0000000..c351980
--- /dev/null
+++ b/dev/scripts/networking/port-forward.sh
@@ -0,0 +1,82 @@
+#!/usr/bin/env bash
+
+# Setup port forwarding from KIND control plane to Envoy Gateway LoadBalancer
+# This allows accessing services via localhost:80/443 on macOS with OrbStack
+
+set -euo pipefail
+
+# Color codes
+RED='\033[0;31m'
+GREEN='\033[0;32m'
+YELLOW='\033[1;33m'
+BLUE='\033[0;34m'
+NC='\033[0m'
+
+log_info() {
+    echo -e "${BLUE}‚ÑπÔ∏è  $1${NC}"
+}
+
+log_success() {
+    echo -e "${GREEN}‚úÖ $1${NC}"
+}
+
+log_warning() {
+    echo -e "${YELLOW}‚ö†Ô∏è  $1${NC}"
+}
+
+log_error() {
+    echo -e "${RED}‚ùå $1${NC}"
+}
+
+CLUSTER_NAME="${CLUSTER_NAME:-nic-operator-dev}"
+
+log_info "Setting up traffic forwarding for LoadBalancer access on macOS"
+echo ""
+
+# Get the LoadBalancer IP
+GATEWAY_IP=$(kubectl get svc -n envoy-gateway-system \
+    -l gateway.envoyproxy.io/owning-gateway-name=nebari-gateway \
+    -o jsonpath='{.items[0].status.loadBalancer.ingress[0].ip}' 2>/dev/null)
+
+if [ -z "$GATEWAY_IP" ]; then
+    log_error "Could not get gateway LoadBalancer IP"
+    exit 1
+fi
+
+log_success "Gateway LoadBalancer IP: ${GATEWAY_IP}"
+
+# Install socat in the control plane node if not present
+log_info "Checking for socat in KIND control plane..."
+if ! docker exec "${CLUSTER_NAME}-control-plane" which socat >/dev/null 2>&1; then
+    log_info "Installing socat..."
+    docker exec "${CLUSTER_NAME}-control-plane" sh -c "apt-get update -qq && apt-get install -y -qq socat" >/dev/null 2>&1
+    log_success "socat installed"
+else
+    log_success "socat already installed"
+fi
+
+# Kill existing socat processes
+log_info "Cleaning up existing port forwards..."
+docker exec "${CLUSTER_NAME}-control-plane" pkill socat 2>/dev/null || true
+
+# Setup port forwarding in the control plane node
+log_info "Setting up port forwarding: 80 -> ${GATEWAY_IP}:80"
+docker exec -d "${CLUSTER_NAME}-control-plane" socat TCP-LISTEN:80,fork,reuseaddr TCP:${GATEWAY_IP}:80
+
+log_info "Setting up port forwarding: 443 -> ${GATEWAY_IP}:443"
+docker exec -d "${CLUSTER_NAME}-control-plane" socat TCP-LISTEN:443,fork,reuseaddr TCP:${GATEWAY_IP}:443
+
+echo ""
+log_success "Port forwarding configured!"
+echo ""
+log_info "You can now access services via:"
+echo "  - HTTP:  http://localhost"
+echo "  - HTTPS: https://localhost"
+echo ""
+log_info "Add hostnames to /etc/hosts for convenience:"
+echo "  echo \"127.0.0.1  sample-app-routing.nebari.local\" | sudo tee -a /etc/hosts"
+echo ""
+log_info "Then access: https://sample-app-routing.nebari.local"
+echo ""
+log_warning "Note: Port forwarding is lost when the cluster is deleted/restarted"
+log_info "Re-run this script after cluster recreation"
diff --git a/dev/scripts/networking/update-hosts.sh b/dev/scripts/networking/update-hosts.sh
new file mode 100755
index 0000000..a2f25ba
--- /dev/null
+++ b/dev/scripts/networking/update-hosts.sh
@@ -0,0 +1,100 @@
+#!/usr/bin/env bash
+
+# Update /etc/hosts with nebari.local hostnames
+# Usage: ./update-hosts.sh [app-name]
+#   - With app-name: adds specific app hostname
+#   - Without app-name: scans all NebariApp resources and adds them
+
+set -euo pipefail
+
+SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
+export CLUSTER_NAME="${CLUSTER_NAME:-nic-operator-dev}"
+
+# Color codes
+RED='\033[0;31m'
+GREEN='\033[0;32m'
+YELLOW='\033[1;33m'
+BLUE='\033[0;34m'
+NC='\033[0m'
+
+log_info() { echo -e "${BLUE}‚ÑπÔ∏è  $1${NC}"; }
+log_success() { echo -e "${GREEN}‚úÖ $1${NC}"; }
+log_warning() { echo -e "${YELLOW}‚ö†Ô∏è  $1${NC}"; }
+log_error() { echo -e "${RED}‚ùå $1${NC}"; }
+
+# Check if cluster exists
+if ! kubectl cluster-info --context "kind-${CLUSTER_NAME}" &>/dev/null; then
+    log_error "Cluster '${CLUSTER_NAME}' not found. Run 'make cluster-create' first."
+    exit 1
+fi
+
+# Get Gateway IP
+GATEWAY_IP=$(kubectl get svc -n envoy-gateway-system -l gateway.envoyproxy.io/owning-gateway-name=nebari-gateway -o jsonpath='{.items[0].status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
+
+if [ -z "${GATEWAY_IP}" ] || [ "${GATEWAY_IP}" == "pending" ]; then
+    log_error "Gateway IP not available. Make sure services are installed: make services-install"
+    exit 1
+fi
+
+# Check if we need sudo
+if [ -w "/etc/hosts" ]; then
+    SUDO_CMD=""
+else
+    SUDO_CMD="sudo"
+fi
+
+# Function to add hostname to /etc/hosts
+add_hostname() {
+    local hostname=$1
+    
+    # Check if hostname already exists in /etc/hosts
+    if grep -q "^[0-9.]\+[[:space:]]\+${hostname}[[:space:]]*# nebari-gateway" /etc/hosts 2>/dev/null; then
+        log_info "Hostname ${hostname} already in /etc/hosts"
+        return 0
+    fi
+    
+    # Add hostname
+    echo "${GATEWAY_IP} ${hostname} # nebari-gateway" | ${SUDO_CMD} tee -a /etc/hosts > /dev/null
+    log_success "Added ${hostname} -> ${GATEWAY_IP}"
+}
+
+# If app name provided, add just that one
+if [ $# -eq 1 ]; then
+    APP_NAME=$1
+    HOSTNAME="${APP_NAME}.nebari.local"
+    
+    log_info "Adding hostname for app: ${APP_NAME}"
+    add_hostname "${HOSTNAME}"
+    
+    log_success "Done! You can now access: https://${HOSTNAME}"
+    exit 0
+fi
+
+# Otherwise, scan all NebariApp resources
+log_info "Scanning for NebariApp resources..."
+
+# Get all NebariApps and extract their hostnames
+HOSTNAMES=$(kubectl get nebariapp --all-namespaces -o jsonpath='{range .items[*]}{.spec.hostname}{"\n"}{end}' 2>/dev/null | grep -v '^$' || echo "")
+
+if [ -z "${HOSTNAMES}" ]; then
+    log_warning "No NebariApp resources found with routing configured"
+    log_info "Usage: $0 [app-name]"
+    log_info "  Example: $0 sample-app-routing"
+    exit 0
+fi
+
+# Add each hostname
+echo "${HOSTNAMES}" | while read -r hostname; do
+    if [ -n "${hostname}" ]; then
+        add_hostname "${hostname}"
+    fi
+done
+
+log_success "All NebariApp hostnames added to /etc/hosts"
+echo ""
+log_info "Added hostnames:"
+echo "${HOSTNAMES}" | while read -r hostname; do
+    if [ -n "${hostname}" ]; then
+        echo "  ‚ûú https://${hostname}"
+    fi
+done
diff --git a/dev/scripts/services/install.sh b/dev/scripts/services/install.sh
new file mode 100755
index 0000000..520479c
--- /dev/null
+++ b/dev/scripts/services/install.sh
@@ -0,0 +1,305 @@
+#!/usr/bin/env bash
+
+# Install foundational services for nic-operator development
+# This script installs:
+# - Envoy Gateway (Gateway API provider)
+# - cert-manager (TLS certificate management)
+# - Gateway and TLS resources
+
+set -euo pipefail
+
+SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
+export CLUSTER_NAME="${CLUSTER_NAME:-nic-operator-dev}"
+
+# Color codes
+RED='\033[0;31m'
+GREEN='\033[0;32m'
+YELLOW='\033[1;33m'
+BLUE='\033[0;34m'
+NC='\033[0m'
+
+log_info() { echo -e "${BLUE}‚ÑπÔ∏è  $1${NC}"; }
+log_success() { echo -e "${GREEN}‚úÖ $1${NC}"; }
+log_warning() { echo -e "${YELLOW}‚ö†Ô∏è  $1${NC}"; }
+log_error() { echo -e "${RED}‚ùå $1${NC}"; }
+
+wait_for_deployment() {
+    local namespace=$1
+    local deployment=$2
+    local timeout=${3:-300}
+
+    log_info "Waiting for deployment ${deployment} in namespace ${namespace}..."
+    if kubectl wait --for=condition=Available deployment/${deployment} -n ${namespace} --timeout=${timeout}s; then
+        log_success "Deployment ${deployment} is ready"
+        return 0
+    else
+        log_error "Deployment ${deployment} failed to become ready"
+        return 1
+    fi
+}
+
+# Check if cluster exists
+if ! kubectl cluster-info --context "kind-${CLUSTER_NAME}" &>/dev/null; then
+    log_error "Cluster '${CLUSTER_NAME}' not found. Run 'make cluster-create' first."
+    exit 1
+fi
+
+echo ""
+echo "üöÄ Installing foundational services to cluster: ${CLUSTER_NAME}"
+echo "=========================================="
+echo ""
+
+# ============================================
+# 1. Install Envoy Gateway with Helm
+# ============================================
+log_info "Installing Envoy Gateway..."
+
+# Create namespace
+kubectl create namespace envoy-gateway-system --dry-run=client -o yaml | kubectl apply -f -
+
+# Install Envoy Gateway with Helm
+log_info "Installing Envoy Gateway via Helm (this may take a few minutes)..."
+helm upgrade --install eg oci://docker.io/envoyproxy/gateway-helm \
+    --version v1.2.4 \
+    --namespace envoy-gateway-system \
+    --wait \
+    --timeout 5m 2>&1 | grep -v "unrecognized format"
+
+# Wait for Gateway API CRDs to be established
+log_info "Waiting for Gateway API CRDs to be established..."
+kubectl wait --for=condition=established --timeout=2m \
+    crd/gateways.gateway.networking.k8s.io \
+    crd/httproutes.gateway.networking.k8s.io \
+    crd/gatewayclasses.gateway.networking.k8s.io
+
+wait_for_deployment "envoy-gateway-system" "envoy-gateway"
+
+log_success "Envoy Gateway installed"
+echo ""
+
+# ============================================
+# 2. Create GatewayClass
+# ============================================
+log_info "Creating GatewayClass..."
+
+cat <<EOF | kubectl apply -f -
+apiVersion: gateway.networking.k8s.io/v1
+kind: GatewayClass
+metadata:
+  name: envoy-gateway
+spec:
+  controllerName: gateway.envoyproxy.io/gatewayclass-controller
+EOF
+
+# Wait for GatewayClass to be accepted
+log_info "Waiting for GatewayClass to be accepted..."
+kubectl wait --for=condition=Accepted gatewayclass/envoy-gateway --timeout=1m
+
+log_success "GatewayClass created and accepted"
+echo ""
+
+# ============================================
+# 3. Install cert-manager with Helm
+# ============================================
+log_info "Installing cert-manager..."
+
+helm repo add jetstack https://charts.jetstack.io 2>/dev/null || true
+helm repo update
+
+helm upgrade --install cert-manager oci://quay.io/jetstack/charts/cert-manager \
+    --namespace cert-manager \
+    --create-namespace \
+    --version v1.16.2 \
+    --set crds.enabled=true \
+    --set config.apiVersion=controller.config.cert-manager.io/v1alpha1 \
+    --set config.kind=ControllerConfiguration \
+    --set config.enableGatewayAPI=true \
+    --wait \
+    --timeout 5m
+
+wait_for_deployment "cert-manager" "cert-manager"
+wait_for_deployment "cert-manager" "cert-manager-webhook"
+wait_for_deployment "cert-manager" "cert-manager-cainjector"
+
+log_success "cert-manager installed with Gateway API support"
+echo ""
+
+# ============================================
+# 4. Create self-signed ClusterIssuer
+# ============================================
+log_info "Creating self-signed ClusterIssuer..."
+
+cat <<EOF | kubectl apply -f -
+---
+apiVersion: cert-manager.io/v1
+kind: ClusterIssuer
+metadata:
+  name: selfsigned-issuer
+spec:
+  selfSigned: {}
+---
+apiVersion: cert-manager.io/v1
+kind: Certificate
+metadata:
+  name: nebari-ca-certificate
+  namespace: cert-manager
+spec:
+  isCA: true
+  commonName: nebari-dev-ca
+  secretName: nebari-ca-secret
+  privateKey:
+    algorithm: ECDSA
+    size: 256
+  issuerRef:
+    name: selfsigned-issuer
+    kind: ClusterIssuer
+---
+apiVersion: cert-manager.io/v1
+kind: ClusterIssuer
+metadata:
+  name: nebari-ca-issuer
+spec:
+  ca:
+    secretName: nebari-ca-secret
+EOF
+
+# Wait for CA certificate
+sleep 5
+kubectl wait --for=condition=Ready certificate/nebari-ca-certificate -n cert-manager --timeout=60s
+
+log_success "ClusterIssuer created"
+echo ""
+
+# ============================================
+# 5. Create wildcard certificate
+# ============================================
+log_info "Creating wildcard certificate..."
+
+cat <<EOF | kubectl apply -f -
+apiVersion: cert-manager.io/v1
+kind: Certificate
+metadata:
+  name: nebari-gateway-cert
+  namespace: envoy-gateway-system
+spec:
+  secretName: nebari-gateway-tls
+  issuerRef:
+    name: nebari-ca-issuer
+    kind: ClusterIssuer
+  commonName: "*.nebari.local"
+  dnsNames:
+  - "*.nebari.local"
+  - "nebari.local"
+EOF
+
+kubectl wait --for=condition=Ready certificate/nebari-gateway-cert -n envoy-gateway-system --timeout=60s
+
+log_success "Wildcard certificate created"
+echo ""
+
+# ============================================
+# 6. Create shared Gateway
+# ============================================
+log_info "Creating shared Gateway..."
+
+cat <<EOF | kubectl apply -f -
+apiVersion: gateway.networking.k8s.io/v1
+kind: Gateway
+metadata:
+  name: nebari-gateway
+  namespace: envoy-gateway-system
+spec:
+  gatewayClassName: envoy-gateway
+  listeners:
+  - name: http
+    protocol: HTTP
+    port: 80
+    allowedRoutes:
+      namespaces:
+        from: All
+  - name: https
+    protocol: HTTPS
+    port: 443
+    allowedRoutes:
+      namespaces:
+        from: All
+    tls:
+      mode: Terminate
+      certificateRefs:
+      - name: nebari-gateway-tls
+        kind: Secret
+EOF
+
+log_success "Gateway created"
+echo ""
+
+# Wait for Gateway to get an address
+log_info "Waiting for Gateway to receive LoadBalancer address..."
+sleep 10
+kubectl wait --for=condition=Programmed gateway/nebari-gateway -n envoy-gateway-system --timeout=120s || \
+    log_warning "Gateway not yet programmed, continuing..."
+
+# ============================================
+# 7. Configure /etc/hosts for nebari.local
+# ============================================
+GATEWAY_IP=$(kubectl get svc -n envoy-gateway-system -l gateway.envoyproxy.io/owning-gateway-name=nebari-gateway -o jsonpath='{.items[0].status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
+
+if [ -n "${GATEWAY_IP}" ] && [ "${GATEWAY_IP}" != "pending" ]; then
+    log_info "Configuring /etc/hosts for nebari.local domains..."
+
+    # Check if we need sudo
+    if [ -w "/etc/hosts" ]; then
+        SUDO_CMD=""
+    else
+        SUDO_CMD="sudo"
+    fi
+
+    # Remove old nebari.local entries
+    ${SUDO_CMD} sed -i.bak '/# nebari-gateway$/d' /etc/hosts 2>/dev/null || true
+
+    # Add base nebari.local entry
+    echo "${GATEWAY_IP} nebari.local # nebari-gateway" | ${SUDO_CMD} tee -a /etc/hosts > /dev/null
+
+    log_success "/etc/hosts configured with Gateway IP: ${GATEWAY_IP}"
+    log_info "To add app-specific hostnames, use: ${SCRIPT_DIR}/../networking/update-hosts.sh <app-name>"
+else
+    log_warning "Gateway IP not available yet. Run '${SCRIPT_DIR}/../networking/update-hosts.sh' later to configure /etc/hosts"
+fi
+
+# ============================================
+# Summary
+# ============================================
+echo ""
+echo "=========================================="
+echo "‚ú® Foundational services installation complete!"
+echo "=========================================="
+echo ""
+echo "üìã Installed components:"
+echo "  ‚úÖ Envoy Gateway (v1.2.4)"
+echo "  ‚úÖ cert-manager (v1.16.2) with Gateway API support"
+echo "  ‚úÖ Self-signed CA ClusterIssuer"
+echo "  ‚úÖ Wildcard certificate (*.nebari.local)"
+echo "  ‚úÖ Shared Gateway (nebari-gateway)"
+if [ -n "${GATEWAY_IP}" ] && [ "${GATEWAY_IP}" != "pending" ]; then
+    echo "  ‚úÖ /etc/hosts configured for nebari.local"
+fi
+echo ""
+echo "üåê Gateway Information:"
+echo "  Name: nebari-gateway"
+echo "  Namespace: envoy-gateway-system"
+echo "  GatewayClass: envoy-gateway"
+if [ -n "${GATEWAY_IP}" ] && [ "${GATEWAY_IP}" != "pending" ]; then
+    echo "  LoadBalancer IP: ${GATEWAY_IP}"
+else
+    echo "  LoadBalancer IP: pending"
+fi
+echo ""
+echo "üìú TLS Certificate:"
+echo "  Secret: nebari-gateway-tls (namespace: envoy-gateway-system)"
+echo "  DNS Names: *.nebari.local, nebari.local"
+echo ""
+echo "Next steps:"
+echo "  1. Deploy the operator: cd .. && make deploy"
+echo "  2. Run e2e tests: cd .. && make test-e2e"
+echo "  3. Create test apps with NebariApp CRD"
+echo ""
diff --git a/dev/scripts/services/uninstall.sh b/dev/scripts/services/uninstall.sh
new file mode 100755
index 0000000..ebf9632
--- /dev/null
+++ b/dev/scripts/services/uninstall.sh
@@ -0,0 +1,61 @@
+#!/usr/bin/env bash
+
+# Uninstall foundational services from nic-operator development cluster
+
+set -euo pipefail
+
+export CLUSTER_NAME="${CLUSTER_NAME:-nic-operator-dev}"
+
+# Color codes
+RED='\033[0;31m'
+GREEN='\033[0;32m'
+YELLOW='\033[1;33m'
+BLUE='\033[0;34m'
+NC='\033[0m'
+
+log_info() { echo -e "${BLUE}‚ÑπÔ∏è  $1${NC}"; }
+log_success() { echo -e "${GREEN}‚úÖ $1${NC}"; }
+log_warning() { echo -e "${YELLOW}‚ö†Ô∏è  $1${NC}"; }
+log_error() { echo -e "${RED}‚ùå $1${NC}"; }
+
+# Check if cluster exists
+if ! kubectl cluster-info --context "kind-${CLUSTER_NAME}" &>/dev/null; then
+    log_warning "Cluster '${CLUSTER_NAME}' not found, nothing to uninstall"
+    exit 0
+fi
+
+echo ""
+echo "üßπ Uninstalling foundational services from cluster: ${CLUSTER_NAME}"
+echo "=========================================="
+echo ""
+
+# Delete Gateway first to cleanup envoy proxy
+log_info "Deleting Gateway resources..."
+kubectl delete gateway nebari-gateway -n envoy-gateway-system --ignore-not-found --timeout=60s
+kubectl delete certificate nebari-gateway-cert -n envoy-gateway-system --ignore-not-found
+
+log_success "Gateway resources deleted"
+
+# Uninstall Envoy Gateway
+log_info "Uninstalling Envoy Gateway..."
+helm uninstall eg -n envoy-gateway-system 2>/dev/null || true
+kubectl delete namespace envoy-gateway-system --ignore-not-found --timeout=60s
+
+log_success "Envoy Gateway uninstalled"
+
+# Uninstall cert-manager
+log_info "Uninstalling cert-manager..."
+helm uninstall cert-manager -n cert-manager 2>/dev/null || true
+kubectl delete namespace cert-manager --ignore-not-found --timeout=60s
+
+log_success "cert-manager uninstalled"
+
+# Uninstall MetalLB
+log_info "Uninstalling MetalLB..."
+kubectl delete -f https://raw.githubusercontent.com/metallb/metallb/v0.14.8/config/manifests/metallb-native.yaml --ignore-not-found 2>/dev/null || true
+
+log_success "MetalLB uninstalled"
+
+echo ""
+log_success "All services uninstalled"
+echo ""
diff --git a/dev/scripts/testing/test-connectivity.sh b/dev/scripts/testing/test-connectivity.sh
new file mode 100755
index 0000000..c6b5bd5
--- /dev/null
+++ b/dev/scripts/testing/test-connectivity.sh
@@ -0,0 +1,160 @@
+#!/usr/bin/env bash
+
+# Test connectivity to a NebariApp via the Gateway
+# Usage: ./test-connectivity.sh <app-name> [namespace]
+
+set -euo pipefail
+
+SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
+export CLUSTER_NAME="${CLUSTER_NAME:-nic-operator-dev}"
+
+# Color codes
+RED='\033[0;31m'
+GREEN='\033[0;32m'
+YELLOW='\033[1;33m'
+BLUE='\033[0;34m'
+NC='\033[0m'
+
+log_info() { echo -e "${BLUE}‚ÑπÔ∏è  $1${NC}"; }
+log_success() { echo -e "${GREEN}‚úÖ $1${NC}"; }
+log_warning() { echo -e "${YELLOW}‚ö†Ô∏è  $1${NC}"; }
+log_error() { echo -e "${RED}‚ùå $1${NC}"; }
+
+# Check arguments
+if [ $# -lt 1 ]; then
+    log_error "Usage: $0 <app-name> [namespace]"
+    echo ""
+    echo "Example:"
+    echo "  $0 sample-app-routing default"
+    echo "  $0 my-app my-namespace"
+    exit 1
+fi
+
+APP_NAME=$1
+NAMESPACE=${2:-default}
+
+# Check if cluster exists
+if ! kubectl cluster-info --context "kind-${CLUSTER_NAME}" &>/dev/null; then
+    log_error "Cluster '${CLUSTER_NAME}' not found. Run 'make cluster-create' first."
+    exit 1
+fi
+
+# Get Gateway IP
+log_info "Getting Gateway IP..."
+GATEWAY_IP=$(kubectl get svc -n envoy-gateway-system -l gateway.envoyproxy.io/owning-gateway-name=nebari-gateway -o jsonpath='{.items[0].status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
+
+if [ -z "${GATEWAY_IP}" ] || [ "${GATEWAY_IP}" == "pending" ]; then
+    log_error "Gateway IP not available. Make sure services are installed: make services-install"
+    exit 1
+fi
+
+log_success "Gateway IP: ${GATEWAY_IP}"
+
+# Check if NebariApp exists
+log_info "Checking if NebariApp '${APP_NAME}' exists in namespace '${NAMESPACE}'..."
+if ! kubectl get nebariapp ${APP_NAME} -n ${NAMESPACE} &>/dev/null; then
+    log_error "NebariApp '${APP_NAME}' not found in namespace '${NAMESPACE}'"
+    exit 1
+fi
+
+# Get hostname
+HOSTNAME=$(kubectl get nebariapp ${APP_NAME} -n ${NAMESPACE} -o jsonpath='{.spec.hostname}' 2>/dev/null || echo "")
+if [ -z "${HOSTNAME}" ]; then
+    log_error "No hostname configured for NebariApp '${APP_NAME}'"
+    exit 1
+fi
+
+log_success "Hostname: ${HOSTNAME}"
+
+# Check TLS enabled
+TLS_ENABLED=$(kubectl get nebariapp ${APP_NAME} -n ${NAMESPACE} -o jsonpath='{.spec.routing.tls.enabled}' 2>/dev/null || echo "true")
+
+# Check if app is ready
+log_info "Checking NebariApp status..."
+READY_STATUS=$(kubectl get nebariapp ${APP_NAME} -n ${NAMESPACE} -o jsonpath='{.status.conditions[?(@.type=="Ready")].status}' 2>/dev/null || echo "Unknown")
+
+if [ "${READY_STATUS}" != "True" ]; then
+    log_warning "NebariApp is not ready (status: ${READY_STATUS})"
+    log_info "You can check the status with: kubectl describe nebariapp ${APP_NAME} -n ${NAMESPACE}"
+else
+    log_success "NebariApp is ready"
+fi
+
+echo ""
+log_info "Testing connectivity..."
+echo ""
+
+# Test HTTP (always try this)
+echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
+echo "Testing HTTP connectivity:"
+echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
+HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --connect-timeout 5 -H "Host: ${HOSTNAME}" "http://${GATEWAY_IP}/" 2>/dev/null || echo "000")
+
+if [ "${HTTP_CODE}" == "301" ] || [ "${HTTP_CODE}" == "302" ]; then
+    echo -e "${YELLOW}HTTP ${HTTP_CODE}${NC} - Redirecting to HTTPS (expected for TLS-enabled apps)"
+elif [ "${HTTP_CODE}" == "200" ]; then
+    echo -e "${GREEN}HTTP ${HTTP_CODE}${NC} - Success!"
+elif [ "${HTTP_CODE}" == "000" ]; then
+    echo -e "${RED}Connection failed${NC}"
+else
+    echo -e "${YELLOW}HTTP ${HTTP_CODE}${NC}"
+fi
+
+echo ""
+echo "Command to test manually:"
+echo "  curl -v -H 'Host: ${HOSTNAME}' http://${GATEWAY_IP}/"
+echo ""
+
+# Test HTTPS if TLS is enabled
+if [ "${TLS_ENABLED}" == "true" ]; then
+    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
+    echo "Testing HTTPS connectivity:"
+    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
+
+    HTTPS_CODE=$(curl -s -o /dev/null -w "%{http_code}" --connect-timeout 5 -k --resolve "${HOSTNAME}:443:${GATEWAY_IP}" "https://${HOSTNAME}/" 2>/dev/null || echo "000")
+
+    if [ "${HTTPS_CODE}" == "200" ]; then
+        echo -e "${GREEN}HTTPS ${HTTPS_CODE}${NC} - Success!"
+    elif [ "${HTTPS_CODE}" == "000" ]; then
+        echo -e "${RED}Connection failed${NC}"
+    else
+        echo -e "${YELLOW}HTTPS ${HTTPS_CODE}${NC}"
+    fi
+
+    echo ""
+    echo "Command to test manually:"
+    echo "  curl -k --resolve '${HOSTNAME}:443:${GATEWAY_IP}' https://${HOSTNAME}/"
+    echo ""
+    echo "Browser URL (after adding to /etc/hosts):"
+    echo "  https://${HOSTNAME}"
+    echo "  (Accept the self-signed certificate warning)"
+fi
+
+# Check /etc/hosts
+echo ""
+echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
+echo "DNS Configuration:"
+echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
+
+if grep -q "^[0-9.]\+[[:space:]]\+${HOSTNAME}[[:space:]]*#.*nebari" /etc/hosts 2>/dev/null; then
+    log_success "Hostname ${HOSTNAME} is in /etc/hosts"
+    echo ""
+    echo "You can access via hostname:"
+    if [ "${TLS_ENABLED}" == "true" ]; then
+        echo "  curl -k https://${HOSTNAME}"
+        echo "  Or in browser: https://${HOSTNAME}"
+    else
+        echo "  curl http://${HOSTNAME}"
+        echo "  Or in browser: http://${HOSTNAME}"
+    fi
+else
+    log_warning "Hostname ${HOSTNAME} is NOT in /etc/hosts"
+    echo ""
+    echo "To add it, run:"
+    echo "  ../networking/update-hosts.sh ${APP_NAME}"
+    echo ""
+    echo "Or manually:"
+    echo "  echo '${GATEWAY_IP} ${HOSTNAME} # nebari-gateway' | sudo tee -a /etc/hosts"
+fi
+
+echo ""
diff --git a/docs/configuration-reference.md b/docs/configuration-reference.md
index 0d45d58..7ff3589 100644
--- a/docs/configuration-reference.md
+++ b/docs/configuration-reference.md
@@ -10,8 +10,7 @@ Resource Definition (CRD).
 - [Spec Fields](#spec-fields)
   - [hostname](#hostname)
   - [service](#service)
-  - [routes](#routes)
-  - [tls](#tls)
+  - [routing](#routing)
   - [auth](#auth)
   - [gateway](#gateway)
 - [Status Fields](#status-fields)
@@ -21,7 +20,7 @@ Resource Definition (CRD).
 
 The `NebariApp` resource represents an application onboarding intent, specifying how an application should be:
 - **Exposed** (routing via HTTPRoute)
-- **Secured** (TLS/HTTPS certificates)
+- **Secured** (TLS/HTTPS via Gateway)
 - **Protected** (OIDC authentication)
 
 ## Basic Structure
@@ -47,7 +46,7 @@ spec:
 **Type:** `string` (required)
 
 The fully qualified domain name (FQDN) where the application should be accessible. This will be used to generate the
-HTTPRoute and configure TLS.
+HTTPRoute resource.
 
 **Validation:**
 - Minimum length: 1
@@ -97,14 +96,21 @@ spec:
 
 
 
-### routes
+### routing
+
+**Type:** `object` (optional)
+
+Configures routing behavior including path-based rules and TLS termination.
+
+#### routing.routes
 
 **Type:** `array` (optional)
 
-Defines path-based routing rules for the application. If not specified, all traffic to the hostname will be routed to
-the service. When specified, only traffic matching these path prefixes will be routed.
+Defines path-based routing rules for the application. If not specified, the Gateway API automatically adds a default path match of `"/"` (PathPrefix), which routes all traffic to the hostname to the service. When specified, only traffic matching these path prefixes will be routed.
+
+**Important:** When no routes are specified, the operator creates an HTTPRoute with an empty matches array, and the Gateway API implementation (Envoy Gateway) automatically adds the default `"/"` path match.
 
-#### routes[].pathPrefix
+##### routing.routes[].pathPrefix
 
 **Type:** `string` (required)
 
@@ -114,7 +120,7 @@ The path prefix to match for routing. Traffic matching this prefix will be route
 - Must start with `/`
 - Examples: `/app-1`, `/api/v1`
 
-#### routes[].pathType
+##### routing.routes[].pathType
 
 **Type:** `string` (optional)
 
@@ -129,76 +135,50 @@ Specifies how the path should be matched.
 **Example:**
 ```yaml
 spec:
-  routes:
-    - pathPrefix: /api/v1
-      pathType: PathPrefix
-    - pathPrefix: /admin
-      pathType: Exact
+  routing:
+    routes:
+      - pathPrefix: /api/v1
+        pathType: PathPrefix
+      - pathPrefix: /admin
+        pathType: Exact
 ```
 
-
-
-### tls
-
-**Type:** `object` (optional)
-
-Configures TLS/HTTPS for the application. If not specified, the application will use the default wildcard certificate.
-
-#### tls.enabled
-
-**Type:** `boolean` (optional)
-
-Determines whether TLS should be configured for this application. When true, the operator will ensure HTTPS is
-available.
-
-**Default:** `true`
-
-#### tls.mode
-
-**Type:** `string` (optional)
-
-Determines how TLS certificates are provisioned.
-
-**Valid values:**
-- `wildcard` (default): Use the shared wildcard certificate (e.g., `*.nebari.local`)
-- `perHost`: Request a dedicated certificate from cert-manager for this hostname
-
-**Default:** `wildcard`
-
-#### tls.issuerRef
+#### routing.tls
 
 **Type:** `object` (optional)
 
-Specifies the cert-manager Issuer/ClusterIssuer to use when `mode` is `perHost`. If not specified, uses the default
-ClusterIssuer `nebari-ca-issuer`.
+Controls TLS termination behavior for the HTTPRoute.
 
-##### tls.issuerRef.name
+**Important:** The operator does not manage TLS certificates or Gateway TLS configuration. cert-manager and
+envoy-gateway handle certificate provisioning and TLS termination. This setting only controls whether the HTTPRoute
+should reference HTTPS listeners on the Gateway.
 
-**Type:** `string` (required)
+##### routing.tls.enabled
 
-Name of the Issuer or ClusterIssuer.
+**Type:** `boolean` (optional)
 
-##### tls.issuerRef.kind
+Determines whether TLS termination should be used. This controls which Gateway listener the HTTPRoute references:
 
-**Type:** `string` (optional)
+- **`true` (default)**: HTTPRoute uses `sectionName: https` to reference the HTTPS listener (port 443)
+- **`false`**: HTTPRoute uses `sectionName: http` to reference the HTTP listener (port 80)
 
-Kind of the issuer.
+**Generated HTTPRoute behavior:**
+- When `enabled: true` (or omitted): `spec.parentRefs[0].sectionName: "https"`
+- When `enabled: false`: `spec.parentRefs[0].sectionName: "http"` and annotation `nebari.dev/tls-enabled: "false"`
 
-**Valid values:**
-- `Issuer`
-- `ClusterIssuer`
+**Note:** The Gateway's TLS certificates are managed by cert-manager, not by this operator. This setting only affects
+which listener the HTTPRoute references.
 
-**Default:** `ClusterIssuer`
+**Default:** `true`
 
 **Example:**
 ```yaml
 spec:
-  tls:
-    enabled: true
-    mode: perHost
-    issuerRef:
-      name: letsencrypt-prod
-      kind: ClusterIssuer
+  routing:
+    routes:
+      - pathPrefix: /api
+    tls:
+      enabled: true
 ```
 
 
@@ -306,7 +286,7 @@ Represents the current state of the NebariApp resource.
 
 **Standard condition types:**
 - `RoutingReady`: HTTPRoute has been created and is functioning
-- `TLSReady`: TLS certificate is available and configured
+- `TLSReady`: TLS termination is functioning (Gateway's TLS listeners are accessible)
 - `AuthReady`: Authentication policy is configured (if auth is enabled)
 - `Ready`: All components are ready (aggregate condition)
 
@@ -318,7 +298,6 @@ Represents the current state of the NebariApp resource.
 - `ServiceNotFound`: The referenced service doesn't exist
 - `SecretNotFound`: The referenced secret doesn't exist
 - `GatewayNotFound`: The target gateway doesn't exist
-- `CertificateNotReady`: The cert-manager Certificate is not ready
 
 ### hostname
 
@@ -390,38 +369,38 @@ spec:
   service:
     name: api-service
     port: 3000
-  routes:
-    - pathPrefix: /api/v1
-      pathType: PathPrefix
-    - pathPrefix: /api/v2
-      pathType: PathPrefix
-    - pathPrefix: /health
-      pathType: Exact
+  routing:
+    routes:
+      - pathPrefix: /api/v1
+        pathType: PathPrefix
+      - pathPrefix: /api/v2
+        pathType: PathPrefix
+      - pathPrefix: /health
+        pathType: Exact
+    tls:
+      enabled: true
 ```
 
 
 
-### Custom TLS Certificate
+### Disable TLS Termination
 
-Using a dedicated certificate from a specific issuer:
+Use HTTP only (no TLS termination at the Gateway):
 
 ```yaml
 apiVersion: reconcilers.nebari.dev/v1
 kind: NebariApp
 metadata:
-  name: secure-app
-  namespace: production
+  name: http-only-app
+  namespace: default
 spec:
-  hostname: secure.example.com
+  hostname: http-app.nebari.local
   service:
-    name: secure-service
-    port: 443
-  tls:
-    enabled: true
-    mode: perHost
-    issuerRef:
-      name: letsencrypt-prod
-      kind: ClusterIssuer
+    name: http-service
+    port: 8080
+  routing:
+    tls:
+      enabled: false
 ```
 
 
@@ -469,17 +448,14 @@ spec:
   service:
     name: backend-service
     port: 8080
-  routes:
-    - pathPrefix: /app
-      pathType: PathPrefix
-    - pathPrefix: /api
-      pathType: PathPrefix
-  tls:
-    enabled: true
-    mode: perHost
-    issuerRef:
-      name: letsencrypt-prod
-      kind: ClusterIssuer
+  routing:
+    routes:
+      - pathPrefix: /app
+        pathType: PathPrefix
+      - pathPrefix: /api
+        pathType: PathPrefix
+    tls:
+      enabled: true
   auth:
     enabled: true
     provider: keycloak
@@ -511,9 +487,9 @@ spec:
     name: internal-service
     port: 8080
   gateway: internal
-  tls:
-    enabled: true
-    mode: wildcard
+  routing:
+    tls:
+      enabled: true
 ```
 
 
diff --git a/docs/routing-integration.md b/docs/routing-integration.md
new file mode 100644
index 0000000..479b519
--- /dev/null
+++ b/docs/routing-integration.md
@@ -0,0 +1,569 @@
+# Routing Integration with Foundational Infrastructure
+
+## Overview
+
+The NIC Operator integrates with the foundational infrastructure's Gateway API resources to provide dynamic routing for
+NebariApp instances. This document explains how the operator interacts with the pre-configured Envoy Gateway,
+cert-manager, and related resources.
+
+## Foundational Infrastructure Components
+
+### Gateway Configuration
+
+The foundational infrastructure deploys a shared Gateway resource that serves as the entry point for all applications:
+
+```yaml
+apiVersion: gateway.networking.k8s.io/v1
+kind: Gateway
+metadata:
+  name: nebari-gateway
+  namespace: envoy-gateway-system
+spec:
+  gatewayClassName: envoy-gateway
+  listeners:
+    - name: http
+      protocol: HTTP
+      port: 80
+      allowedRoutes:
+        namespaces:
+          from: All
+    - name: https
+      protocol: HTTPS
+      port: 443
+      allowedRoutes:
+        namespaces:
+          from: All
+      tls:
+        mode: Terminate
+        certificateRefs:
+          - name: nebari-gateway-tls
+            kind: Secret
+```
+
+**Key Properties:**
+- **Name**: `nebari-gateway`
+- **Namespace**: `envoy-gateway-system`
+- **Gateway Class**: `envoy-gateway`
+- **Listeners**: HTTP (80) and HTTPS (443)
+- **TLS Certificate**: `nebari-gateway-tls` (wildcard cert for `*.nebari.local`)
+- **Route Namespaces**: Allows routes from all namespaces
+
+### GatewayClass
+
+The Gateway uses the Envoy Gateway controller:
+
+```yaml
+apiVersion: gateway.networking.k8s.io/v1
+kind: GatewayClass
+metadata:
+  name: envoy-gateway
+spec:
+  controllerName: gateway.envoyproxy.io/gatewayclass-controller
+```
+
+### TLS Certificate Management
+
+#### Wildcard Certificate
+
+The foundational infrastructure provisions a wildcard certificate for all subdomains:
+
+```yaml
+apiVersion: cert-manager.io/v1
+kind: Certificate
+metadata:
+  name: nebari-gateway-cert
+  namespace: envoy-gateway-system
+spec:
+  secretName: nebari-gateway-tls
+  duration: 8760h # 1 year
+  renewBefore: 720h # 30 days
+  issuerRef:
+    name: selfsigned-issuer  # or letsencrypt-issuer for production
+    kind: ClusterIssuer
+  commonName: "*.nebari.local"
+  dnsNames:
+    - "*.nebari.local"
+    - "nebari.local"
+    - "keycloak.nebari.local"
+    - "argocd.nebari.local"
+```
+
+**Certificate Details:**
+- **Secret Name**: `nebari-gateway-tls`
+- **Pattern**: Wildcard (`*.nebari.local`)
+- **Renewal**: 30 days before expiration
+- **Storage**: Secret in `envoy-gateway-system` namespace
+
+#### ClusterIssuer
+
+For production environments with Let's Encrypt:
+
+```yaml
+apiVersion: cert-manager.io/v1
+kind: ClusterIssuer
+metadata:
+  name: letsencrypt-issuer
+spec:
+  acme:
+    email: admin@example.com
+    server: https://acme-v02.api.letsencrypt.org/directory
+    privateKeySecretRef:
+      name: letsencrypt-account-key
+    solvers:
+      - http01:
+          gatewayHTTPRoute:
+            parentRefs:
+              - name: nebari-gateway
+                namespace: envoy-gateway-system
+                kind: Gateway
+```
+
+**HTTP-01 Challenge**: Uses the Gateway API HTTP-01 solver, which creates temporary HTTPRoutes for ACME challenges.
+
+## NebariApp HTTPRoute Generation
+
+### Basic HTTPRoute Structure
+
+When a NebariApp is created, the operator generates an HTTPRoute resource:
+
+```yaml
+apiVersion: gateway.networking.k8s.io/v1
+kind: HTTPRoute
+metadata:
+  name: myapp-route
+  namespace: myapp-namespace
+  labels:
+    app.kubernetes.io/name: nicapp
+    app.kubernetes.io/instance: myapp
+    app.kubernetes.io/managed-by: nic-operator
+spec:
+  parentRefs:
+    - name: nebari-gateway
+      namespace: envoy-gateway-system
+  hostnames:
+    - "myapp.nebari.local"
+  rules:
+    - matches:
+        - path:
+            type: PathPrefix
+            value: /
+      backendRefs:
+        - name: myapp-service
+          port: 8080
+```
+
+### Parent Reference Configuration
+
+**Critical**: HTTPRoutes must reference the Gateway in the `envoy-gateway-system` namespace:
+
+```yaml
+spec:
+  parentRefs:
+    - name: nebari-gateway
+      namespace: envoy-gateway-system
+      sectionName: https  # or "http" when TLS is disabled
+```
+
+The `sectionName` field determines which Gateway listener to use:
+- `https` - Uses the HTTPS listener (port 443) with TLS termination (default)
+- `http` - Uses the HTTP listener (port 80) without TLS (when `routing.tls.enabled: false`)
+
+This allows the operator to create HTTPRoutes in application namespaces while referencing the shared Gateway.
+
+### Hostname Configuration
+
+The operator uses the `hostname` field from the NebariApp spec:
+
+```yaml
+apiVersion: reconcilers.nebari.dev/v1
+kind: NebariApp
+metadata:
+  name: myapp
+  namespace: myapp-namespace
+spec:
+  hostname: myapp.nebari.local  # Must match wildcard cert pattern
+  service:
+    name: myapp-service
+    port: 8080
+```
+
+**Hostname Requirements:**
+- Must be a subdomain of the wildcard certificate (`*.nebari.local`)
+- Must be a valid DNS name
+- Must be unique across all NebariApp resources
+
+### Path-Based Routing
+
+#### Default Routing (No Paths Specified)
+
+When no routes are specified in the NebariApp, the operator creates an HTTPRoute with an empty `matches` array. The Gateway API (Envoy Gateway) automatically adds a default path match of `"/"` with type `PathPrefix` when the matches array is empty or null.
+
+**NebariApp spec (no routes):**
+```yaml
+apiVersion: reconcilers.nebari.dev/v1
+kind: NebariApp
+spec:
+  hostname: myapp.nebari.local
+  service:
+    name: myapp-service
+    port: 8080
+  routing:
+    tls:
+      enabled: true
+  # No routes specified
+```
+
+**Resulting HTTPRoute (after Gateway API adds default):**
+```yaml
+rules:
+  - matches:
+      - path:
+          type: PathPrefix
+          value: /
+    backendRefs:
+      - name: myapp-service
+        port: 8080
+```
+
+**Note:** The `"/"` path match is added automatically by the Gateway API implementation, not by the operator.
+
+#### Custom Path Routing
+
+When specific paths are configured:
+
+```yaml
+apiVersion: reconcilers.nebari.dev/v1
+kind: NebariApp
+spec:
+  hostname: myapp.nebari.local
+  service:
+    name: myapp-service
+    port: 8080
+  routing:
+    routes:
+      - pathPrefix: /api/v1
+        pathType: PathPrefix
+      - pathPrefix: /app
+        pathType: Exact
+```
+
+**Generates (single rule with multiple matches):**
+
+```yaml
+rules:
+  - matches:
+      - path:
+          type: PathPrefix
+          value: /api/v1
+      - path:
+          type: Exact
+          value: /app
+    backendRefs:
+      - name: myapp-service
+        port: 8080
+```
+
+**Note:** All path rules are combined into a single HTTPRoute rule with multiple matches, following Gateway API best practices. All matches route to the same backend service.
+
+### Backend References
+
+The operator creates backend references using the service details from the NebariApp spec:
+
+```yaml
+backendRefs:
+  - name: myapp-service  # From spec.service.name
+    port: 8080           # From spec.service.port
+```
+
+**Important**: The backend service must:
+- Exist in the same namespace as the NebariApp
+- Expose the specified port
+- Be validated during core reconciliation
+
+## TLS Configuration
+
+### TLS Termination (Default)
+
+By default, NebariApps use TLS termination with the wildcard certificate provisioned by the foundational infrastructure:
+
+```yaml
+apiVersion: reconcilers.nebari.dev/v1
+kind: NebariApp
+spec:
+  hostname: myapp.nebari.local
+  service:
+    name: myapp-service
+    port: 8080
+  # TLS enabled by default
+  routing:
+    tls:
+      enabled: true  # default, can be omitted
+```
+
+**Generated HTTPRoute:**
+```yaml
+spec:
+  parentRefs:
+    - name: nebari-gateway
+      namespace: envoy-gateway-system
+      sectionName: https  # References HTTPS listener
+```
+
+**Flow:**
+1. HTTPRoute created with `sectionName: https` to reference HTTPS listener
+2. Gateway HTTPS listener (443) uses existing `nebari-gateway-tls` secret
+3. TLS termination handled at Gateway level by envoy-gateway
+4. Traffic forwarded to backend service over HTTP
+
+**Important**: The operator does **not** manage TLS certificates or Gateway TLS configuration. This is handled by:
+- **cert-manager**: Provisions and renews certificates
+- **Gateway**: Configures TLS listeners and termination
+- **NebariApp**: Only controls whether HTTPRoute references HTTPS (`sectionName: https`) or HTTP (`sectionName: http`)
+  listeners via the `routing.tls.enabled` field
+
+### Disable TLS (HTTP Only)
+
+To disable TLS termination and use HTTP only:
+
+```yaml
+apiVersion: reconcilers.nebari.dev/v1
+kind: NebariApp
+spec:
+  hostname: http-app.nebari.local
+  service:
+    name: myapp-service
+    port: 8080
+  routing:
+    tls:
+      enabled: false  # Use HTTP listener only
+```
+
+**Generated HTTPRoute:**
+```yaml
+metadata:
+  annotations:
+    nebari.dev/tls-enabled: "false"
+spec:
+  parentRefs:
+    - name: nebari-gateway
+      namespace: envoy-gateway-system
+      sectionName: http  # References HTTP listener (port 80)
+```
+
+**Note**: This is typically only needed for:
+- Development/testing environments
+- Internal services that handle their own TLS
+- Services that require HTTP for specific protocols
+
+## Gateway Selection
+
+### Public Gateway (Default)
+
+```yaml
+apiVersion: reconcilers.nebari.dev/v1
+kind: NebariApp
+spec:
+  gateway: public  # or omit for default
+  hostname: myapp.nebari.local
+```
+
+Routes to: `nebari-gateway` in `envoy-gateway-system`
+
+### Internal Gateway (Future)
+
+For internal-only services:
+
+```yaml
+apiVersion: reconcilers.nebari.dev/v1
+kind: NebariApp
+spec:
+  gateway: internal
+  hostname: internal-app.nebari.local
+```
+
+Routes to: `nebari-internal-gateway` in `envoy-gateway-system` (if deployed)
+
+## Routing Reconciliation Flow
+
+### 1. Gateway Validation
+
+Before creating HTTPRoute, the operator validates:
+- Gateway exists in `envoy-gateway-system`
+- Gateway is in Ready state
+- Gateway has appropriate listeners configured
+
+### 2. HTTPRoute Creation
+
+```go
+func (r *RoutingReconciler) ReconcileRouting(ctx context.Context, nebariApp *NebariApp) error {
+    // 1. Determine gateway name based on spec.gateway
+    gatewayName := r.getGatewayName(nebariApp)
+
+    // 2. Validate gateway exists
+    if err := r.validateGateway(ctx, gatewayName); err != nil {
+        // Set condition: RoutingReady=False, Reason=GatewayNotFound
+        return err
+    }
+
+    // 3. Build desired HTTPRoute
+    desiredRoute := r.buildHTTPRoute(nebariApp, gatewayName)
+
+    // 4. Create or update HTTPRoute
+    // ...
+
+    // 5. Set condition: RoutingReady=True
+    return nil
+}
+```
+
+### 3. Status Updates
+
+The operator maintains the `RoutingReady` condition:
+
+**Success:**
+```yaml
+status:
+  conditions:
+    - type: RoutingReady
+      status: "True"
+      reason: HTTPRouteReady
+      message: "HTTPRoute is configured and ready"
+```
+
+**Failure:**
+```yaml
+status:
+  conditions:
+    - type: RoutingReady
+      status: "False"
+      reason: GatewayNotFound
+      message: "Gateway nebari-gateway not found in namespace envoy-gateway-system"
+```
+
+## Example Integration
+
+### Full NebariApp Example
+
+```yaml
+apiVersion: reconcilers.nebari.dev/v1
+kind: NebariApp
+metadata:
+  name: jupyter-app
+  namespace: jupyter
+spec:
+  hostname: jupyter.nebari.local
+  service:
+    name: jupyterhub
+    port: 8000
+  routing:
+    routes:
+      - pathPrefix: /
+        pathType: PathPrefix
+    tls:
+      enabled: true
+  gateway: public
+```
+
+### Generated HTTPRoute
+
+```yaml
+apiVersion: gateway.networking.k8s.io/v1
+kind: HTTPRoute
+metadata:
+  name: jupyter-app-route
+  namespace: jupyter
+  ownerReferences:
+    - apiVersion: reconcilers.nebari.dev/v1
+      kind: NebariApp
+      name: jupyter-app
+      controller: true
+spec:
+  parentRefs:
+    - name: nebari-gateway
+      namespace: envoy-gateway-system
+  hostnames:
+    - jupyter.nebari.local
+  rules:
+    - matches:
+        - path:
+            type: PathPrefix
+            value: /
+      backendRefs:
+        - name: jupyterhub
+          port: 8000
+```
+
+### Traffic Flow
+
+```
+User Request: https://jupyter.nebari.local/
+              ‚Üì
+[Gateway Listener (443)]
+  - TLS Termination (nebari-gateway-tls)
+              ‚Üì
+[HTTPRoute Matching]
+  - Hostname: jupyter.nebari.local
+  - Path: / (PathPrefix)
+              ‚Üì
+[Backend Service]
+  - Service: jupyter/jupyterhub:8000
+              ‚Üì
+[Pod]
+  - JupyterHub application
+```
+
+## Troubleshooting
+
+### HTTPRoute Not Created
+
+**Check:**
+1. Gateway exists: `kubectl get gateway nebari-gateway -n envoy-gateway-system`
+2. NebariApp events: `kubectl describe nebariapp <name> -n <namespace>`
+3. Controller logs for validation errors
+
+### Hostname Not Resolving
+
+**Check:**
+1. HTTPRoute created: `kubectl get httproute -n <namespace>`
+2. Gateway has HTTPS listener configured
+3. TLS secret exists: `kubectl get secret nebari-gateway-tls -n envoy-gateway-system`
+4. DNS resolves to Gateway external IP
+
+### Certificate Errors
+
+**Check:**
+1. Hostname matches wildcard pattern (`*.nebari.local`)
+2. Certificate is valid: `kubectl get certificate -n envoy-gateway-system`
+3. TLS secret contains valid cert data
+
+### Backend Connection Failures
+
+**Check:**
+1. Service exists and is in same namespace
+2. Service exposes the correct port
+3. Pods are running and healthy
+4. HTTPRoute backendRefs match service name/port
+
+## Configuration Constants
+
+The operator uses these constants for infrastructure integration:
+
+```go
+const (
+    PublicGatewayName    = "nebari-gateway"
+    InternalGatewayName  = "nebari-internal-gateway"
+    GatewayNamespace     = "envoy-gateway-system"
+    GatewayClassName     = "envoy-gateway"
+    DefaultTLSSecretName = "nebari-gateway-tls"
+)
+```
+
+These match the resources deployed by the foundational infrastructure via ArgoCD.
+
+## Related Documentation
+
+- [Core Validation](./core-validation.md)
+- [NebariApp API Specification](../api/v1/nebariapp_types.go)
+- [Gateway API Documentation](https://gateway-api.sigs.k8s.io/)
+- [Envoy Gateway](https://gateway.envoyproxy.io/)
+- [cert-manager](https://cert-manager.io/)
diff --git a/go.mod b/go.mod
index b80f28b..22c9d0a 100644
--- a/go.mod
+++ b/go.mod
@@ -5,9 +5,11 @@ go 1.24.6
 require (
 	github.com/onsi/ginkgo/v2 v2.22.0
 	github.com/onsi/gomega v1.36.1
+	k8s.io/api v0.34.1
 	k8s.io/apimachinery v0.34.1
 	k8s.io/client-go v0.34.1
 	sigs.k8s.io/controller-runtime v0.22.4
+	sigs.k8s.io/gateway-api v1.4.1
 )
 
 require (
@@ -17,18 +19,18 @@ require (
 	github.com/blang/semver/v4 v4.0.0 // indirect
 	github.com/cenkalti/backoff/v4 v4.3.0 // indirect
 	github.com/cespare/xxhash/v2 v2.3.0 // indirect
-	github.com/davecgh/go-spew v1.1.1 // indirect
-	github.com/emicklei/go-restful/v3 v3.12.2 // indirect
+	github.com/davecgh/go-spew v1.1.2-0.20180830191138-d8f796af33cc // indirect
+	github.com/emicklei/go-restful/v3 v3.13.0 // indirect
 	github.com/evanphx/json-patch/v5 v5.9.11 // indirect
 	github.com/felixge/httpsnoop v1.0.4 // indirect
 	github.com/fsnotify/fsnotify v1.9.0 // indirect
 	github.com/fxamacker/cbor/v2 v2.9.0 // indirect
-	github.com/go-logr/logr v1.4.2 // indirect
+	github.com/go-logr/logr v1.4.3 // indirect
 	github.com/go-logr/stdr v1.2.2 // indirect
 	github.com/go-logr/zapr v1.3.0 // indirect
-	github.com/go-openapi/jsonpointer v0.21.0 // indirect
-	github.com/go-openapi/jsonreference v0.20.2 // indirect
-	github.com/go-openapi/swag v0.23.0 // indirect
+	github.com/go-openapi/jsonpointer v0.21.2 // indirect
+	github.com/go-openapi/jsonreference v0.21.0 // indirect
+	github.com/go-openapi/swag v0.23.1 // indirect
 	github.com/go-task/slim-sprig/v3 v3.0.0 // indirect
 	github.com/gogo/protobuf v1.3.2 // indirect
 	github.com/google/btree v1.1.3 // indirect
@@ -41,59 +43,57 @@ require (
 	github.com/inconshreveable/mousetrap v1.1.0 // indirect
 	github.com/josharian/intern v1.0.0 // indirect
 	github.com/json-iterator/go v1.1.12 // indirect
-	github.com/mailru/easyjson v0.7.7 // indirect
+	github.com/mailru/easyjson v0.9.0 // indirect
 	github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect
 	github.com/modern-go/reflect2 v1.0.3-0.20250322232337-35a7c28c31ee // indirect
 	github.com/munnerz/goautoneg v0.0.0-20191010083416-a7dc8b61c822 // indirect
-	github.com/pkg/errors v0.9.1 // indirect
-	github.com/pmezard/go-difflib v1.0.0 // indirect
-	github.com/prometheus/client_golang v1.22.0 // indirect
-	github.com/prometheus/client_model v0.6.1 // indirect
-	github.com/prometheus/common v0.62.0 // indirect
-	github.com/prometheus/procfs v0.15.1 // indirect
+	github.com/pmezard/go-difflib v1.0.1-0.20181226105442-5d4384ee4fb2 // indirect
+	github.com/prometheus/client_golang v1.23.0 // indirect
+	github.com/prometheus/client_model v0.6.2 // indirect
+	github.com/prometheus/common v0.65.0 // indirect
+	github.com/prometheus/procfs v0.17.0 // indirect
 	github.com/spf13/cobra v1.9.1 // indirect
-	github.com/spf13/pflag v1.0.6 // indirect
+	github.com/spf13/pflag v1.0.7 // indirect
 	github.com/stoewer/go-strcase v1.3.0 // indirect
 	github.com/x448/float16 v0.8.4 // indirect
 	go.opentelemetry.io/auto/sdk v1.1.0 // indirect
 	go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.58.0 // indirect
-	go.opentelemetry.io/otel v1.35.0 // indirect
+	go.opentelemetry.io/otel v1.37.0 // indirect
 	go.opentelemetry.io/otel/exporters/otlp/otlptrace v1.34.0 // indirect
 	go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc v1.34.0 // indirect
-	go.opentelemetry.io/otel/metric v1.35.0 // indirect
-	go.opentelemetry.io/otel/sdk v1.34.0 // indirect
-	go.opentelemetry.io/otel/trace v1.35.0 // indirect
+	go.opentelemetry.io/otel/metric v1.37.0 // indirect
+	go.opentelemetry.io/otel/sdk v1.37.0 // indirect
+	go.opentelemetry.io/otel/trace v1.37.0 // indirect
 	go.opentelemetry.io/proto/otlp v1.5.0 // indirect
 	go.uber.org/multierr v1.11.0 // indirect
 	go.uber.org/zap v1.27.0 // indirect
 	go.yaml.in/yaml/v2 v2.4.2 // indirect
 	go.yaml.in/yaml/v3 v3.0.4 // indirect
 	golang.org/x/exp v0.0.0-20240719175910-8a7402abbf56 // indirect
-	golang.org/x/net v0.38.0 // indirect
-	golang.org/x/oauth2 v0.27.0 // indirect
-	golang.org/x/sync v0.12.0 // indirect
-	golang.org/x/sys v0.31.0 // indirect
-	golang.org/x/term v0.30.0 // indirect
-	golang.org/x/text v0.23.0 // indirect
-	golang.org/x/time v0.9.0 // indirect
-	golang.org/x/tools v0.26.0 // indirect
+	golang.org/x/net v0.43.0 // indirect
+	golang.org/x/oauth2 v0.30.0 // indirect
+	golang.org/x/sync v0.16.0 // indirect
+	golang.org/x/sys v0.35.0 // indirect
+	golang.org/x/term v0.34.0 // indirect
+	golang.org/x/text v0.28.0 // indirect
+	golang.org/x/time v0.12.0 // indirect
+	golang.org/x/tools v0.36.0 // indirect
 	gomodules.xyz/jsonpatch/v2 v2.4.0 // indirect
-	google.golang.org/genproto/googleapis/api v0.0.0-20250303144028-a0af3efb3deb // indirect
-	google.golang.org/genproto/googleapis/rpc v0.0.0-20250303144028-a0af3efb3deb // indirect
-	google.golang.org/grpc v1.72.1 // indirect
-	google.golang.org/protobuf v1.36.5 // indirect
-	gopkg.in/evanphx/json-patch.v4 v4.12.0 // indirect
+	google.golang.org/genproto/googleapis/api v0.0.0-20250707201910-8d1bb00bc6a7 // indirect
+	google.golang.org/genproto/googleapis/rpc v0.0.0-20250826171959-ef028d996bc1 // indirect
+	google.golang.org/grpc v1.75.1 // indirect
+	google.golang.org/protobuf v1.36.8 // indirect
+	gopkg.in/evanphx/json-patch.v4 v4.13.0 // indirect
 	gopkg.in/inf.v0 v0.9.1 // indirect
 	gopkg.in/yaml.v3 v3.0.1 // indirect
-	k8s.io/api v0.34.1 // indirect
 	k8s.io/apiextensions-apiserver v0.34.1 // indirect
 	k8s.io/apiserver v0.34.1 // indirect
 	k8s.io/component-base v0.34.1 // indirect
 	k8s.io/klog/v2 v2.130.1 // indirect
-	k8s.io/kube-openapi v0.0.0-20250710124328-f3f2b991d03b // indirect
-	k8s.io/utils v0.0.0-20250604170112-4c0f3b243397 // indirect
+	k8s.io/kube-openapi v0.0.0-20250814151709-d7b6acb124c3 // indirect
+	k8s.io/utils v0.0.0-20250820121507-0af2bda4dd1d // indirect
 	sigs.k8s.io/apiserver-network-proxy/konnectivity-client v0.31.2 // indirect
-	sigs.k8s.io/json v0.0.0-20241014173422-cfa47c3a1cc8 // indirect
+	sigs.k8s.io/json v0.0.0-20250730193827-2d320260d730 // indirect
 	sigs.k8s.io/randfill v1.0.0 // indirect
 	sigs.k8s.io/structured-merge-diff/v6 v6.3.0 // indirect
 	sigs.k8s.io/yaml v1.6.0 // indirect
diff --git a/go.sum b/go.sum
index 3797258..a9803ee 100644
--- a/go.sum
+++ b/go.sum
@@ -11,12 +11,12 @@ github.com/cenkalti/backoff/v4 v4.3.0/go.mod h1:Y3VNntkOUPxTVeUxJ/G5vcM//AlwfmyY
 github.com/cespare/xxhash/v2 v2.3.0 h1:UL815xU9SqsFlibzuggzjXhog7bL6oX9BbNZnL2UFvs=
 github.com/cespare/xxhash/v2 v2.3.0/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=
 github.com/cpuguy83/go-md2man/v2 v2.0.6/go.mod h1:oOW0eioCTA6cOiMLiUPZOpcVxMig6NIQQ7OS05n1F4g=
-github.com/creack/pty v1.1.9/go.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=
 github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
-github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
 github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
-github.com/emicklei/go-restful/v3 v3.12.2 h1:DhwDP0vY3k8ZzE0RunuJy8GhNpPL6zqLkDf9B/a0/xU=
-github.com/emicklei/go-restful/v3 v3.12.2/go.mod h1:6n3XBCmQQb25CM2LCACGz8ukIrRry+4bhvbpWn3mrbc=
+github.com/davecgh/go-spew v1.1.2-0.20180830191138-d8f796af33cc h1:U9qPSI2PIWSS1VwoXQT9A3Wy9MM3WgvqSxFWenqJduM=
+github.com/davecgh/go-spew v1.1.2-0.20180830191138-d8f796af33cc/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
+github.com/emicklei/go-restful/v3 v3.13.0 h1:C4Bl2xDndpU6nJ4bc1jXd+uTmYPVUwkD6bFY/oTyCes=
+github.com/emicklei/go-restful/v3 v3.13.0/go.mod h1:6n3XBCmQQb25CM2LCACGz8ukIrRry+4bhvbpWn3mrbc=
 github.com/evanphx/json-patch v0.5.2 h1:xVCHIVMUu1wtM/VkR9jVZ45N3FhZfYMMYGorLCR8P3k=
 github.com/evanphx/json-patch v0.5.2/go.mod h1:ZWS5hhDbVDyob71nXKNL0+PWn6ToqBHMikGIFbs31qQ=
 github.com/evanphx/json-patch/v5 v5.9.11 h1:/8HVnzMq13/3x9TPvjG08wUGqBTmZBsCWzjTM0wiaDU=
@@ -28,20 +28,18 @@ github.com/fsnotify/fsnotify v1.9.0/go.mod h1:8jBTzvmWwFyi3Pb8djgCCO5IBqzKJ/Jwo8
 github.com/fxamacker/cbor/v2 v2.9.0 h1:NpKPmjDBgUfBms6tr6JZkTHtfFGcMKsw3eGcmD/sapM=
 github.com/fxamacker/cbor/v2 v2.9.0/go.mod h1:vM4b+DJCtHn+zz7h3FFp/hDAI9WNWCsZj23V5ytsSxQ=
 github.com/go-logr/logr v1.2.2/go.mod h1:jdQByPbusPIv2/zmleS9BjJVeZ6kBagPoEUsqbVz/1A=
-github.com/go-logr/logr v1.4.2 h1:6pFjapn8bFcIbiKo3XT4j/BhANplGihG6tvd+8rYgrY=
-github.com/go-logr/logr v1.4.2/go.mod h1:9T104GzyrTigFIr8wt5mBrctHMim0Nb2HLGrmQ40KvY=
+github.com/go-logr/logr v1.4.3 h1:CjnDlHq8ikf6E492q6eKboGOC0T8CDaOvkHCIg8idEI=
+github.com/go-logr/logr v1.4.3/go.mod h1:9T104GzyrTigFIr8wt5mBrctHMim0Nb2HLGrmQ40KvY=
 github.com/go-logr/stdr v1.2.2 h1:hSWxHoqTgW2S2qGc0LTAI563KZ5YKYRhT3MFKZMbjag=
 github.com/go-logr/stdr v1.2.2/go.mod h1:mMo/vtBO5dYbehREoey6XUKy/eSumjCCveDpRre4VKE=
 github.com/go-logr/zapr v1.3.0 h1:XGdV8XW8zdwFiwOA2Dryh1gj2KRQyOOoNmBy4EplIcQ=
 github.com/go-logr/zapr v1.3.0/go.mod h1:YKepepNBd1u/oyhd/yQmtjVXmm9uML4IXUgMOwR8/Gg=
-github.com/go-openapi/jsonpointer v0.19.6/go.mod h1:osyAmYz/mB/C3I+WsTTSgw1ONzaLJoLCyoi6/zppojs=
-github.com/go-openapi/jsonpointer v0.21.0 h1:YgdVicSA9vH5RiHs9TZW5oyafXZFc6+2Vc1rr/O9oNQ=
-github.com/go-openapi/jsonpointer v0.21.0/go.mod h1:IUyH9l/+uyhIYQ/PXVA41Rexl+kOkAPDdXEYns6fzUY=
-github.com/go-openapi/jsonreference v0.20.2 h1:3sVjiK66+uXK/6oQ8xgcRKcFgQ5KXa2KvnJRumpMGbE=
-github.com/go-openapi/jsonreference v0.20.2/go.mod h1:Bl1zwGIM8/wsvqjsOQLJ/SH+En5Ap4rVB5KVcIDZG2k=
-github.com/go-openapi/swag v0.22.3/go.mod h1:UzaqsxGiab7freDnrUUra0MwWfN/q7tE4j+VcZ0yl14=
-github.com/go-openapi/swag v0.23.0 h1:vsEVJDUo2hPJ2tu0/Xc+4noaxyEffXNIs3cOULZ+GrE=
-github.com/go-openapi/swag v0.23.0/go.mod h1:esZ8ITTYEsH1V2trKHjAN8Ai7xHb8RV+YSZ577vPjgQ=
+github.com/go-openapi/jsonpointer v0.21.2 h1:AqQaNADVwq/VnkCmQg6ogE+M3FOsKTytwges0JdwVuA=
+github.com/go-openapi/jsonpointer v0.21.2/go.mod h1:50I1STOfbY1ycR8jGz8DaMeLCdXiI6aDteEdRNNzpdk=
+github.com/go-openapi/jsonreference v0.21.0 h1:Rs+Y7hSXT83Jacb7kFyjn4ijOuVGSvOdF2+tg1TRrwQ=
+github.com/go-openapi/jsonreference v0.21.0/go.mod h1:LmZmgsrTkVg9LG4EaHeY8cBDslNPMo06cago5JNLkm4=
+github.com/go-openapi/swag v0.23.1 h1:lpsStH0n2ittzTnbaSloVZLuB5+fvSY/+hnagBjSNZU=
+github.com/go-openapi/swag v0.23.1/go.mod h1:STZs8TbRvEQQKUA+JZNAm3EWlgaOBGpyFDqQnDHMef0=
 github.com/go-task/slim-sprig/v3 v3.0.0 h1:sUs3vkvUymDpBKi3qH1YSqBQk9+9D/8M2mN1vB6EwHI=
 github.com/go-task/slim-sprig/v3 v3.0.0/go.mod h1:W848ghGpv3Qj3dhTPRyJypKRiqCdHZiAzKg9hl15HA8=
 github.com/gogo/protobuf v1.3.2 h1:Ov1cvc58UF3b5XjBnZv7+opcTcQFZebYjWzi34vdm4Q=
@@ -75,17 +73,14 @@ github.com/kisielk/errcheck v1.5.0/go.mod h1:pFxgyoBC7bSaBwPgfKdkLd5X25qrDl4LWUI
 github.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+oQHNcck=
 github.com/klauspost/compress v1.18.0 h1:c/Cqfb0r+Yi+JtIEq73FWXVkRonBlf0CRNYc8Zttxdo=
 github.com/klauspost/compress v1.18.0/go.mod h1:2Pp+KzxcywXVXMr50+X0Q/Lsb43OQHYWRCY2AiWywWQ=
-github.com/kr/pretty v0.2.1/go.mod h1:ipq/a2n7PKx3OHsz4KJII5eveXtPO4qwEXGdVfWzfnI=
 github.com/kr/pretty v0.3.1 h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=
 github.com/kr/pretty v0.3.1/go.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=
-github.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=
-github.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=
 github.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=
 github.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=
 github.com/kylelemons/godebug v1.1.0 h1:RPNrshWIDI6G2gRW9EHilWtl7Z6Sb1BR0xunSBf0SNc=
 github.com/kylelemons/godebug v1.1.0/go.mod h1:9/0rRGxNHcop5bhtWyNeEfOS8JIWk580+fNqagV/RAw=
-github.com/mailru/easyjson v0.7.7 h1:UGYAvKxe3sBsEDzO8ZeWOSlIQfWFlxbzLZe7hwFURr0=
-github.com/mailru/easyjson v0.7.7/go.mod h1:xzfreul335JAWq5oZzymOObrkdz5UnU4kGfJJLY9Nlc=
+github.com/mailru/easyjson v0.9.0 h1:PrnmzHw7262yW8sTBwxi1PdJA3Iw/EKBa8psRf7d9a4=
+github.com/mailru/easyjson v0.9.0/go.mod h1:1+xMtQp2MRNVL/V1bOzuP3aP8VNwRW55fQUto+XFtTU=
 github.com/modern-go/concurrent v0.0.0-20180228061459-e0a39a4cb421/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=
 github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd h1:TRLaZ9cD/w8PVh93nsPXa1VrQ6jlwL5oN8l14QlcNfg=
 github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=
@@ -100,23 +95,25 @@ github.com/onsi/gomega v1.36.1 h1:bJDPBO7ibjxcbHMgSCoo4Yj18UWbKDlLwX1x9sybDcw=
 github.com/onsi/gomega v1.36.1/go.mod h1:PvZbdDc8J6XJEpDK4HCuRBm8a6Fzp9/DmhC9C7yFlog=
 github.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=
 github.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=
-github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
 github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
-github.com/prometheus/client_golang v1.22.0 h1:rb93p9lokFEsctTys46VnV1kLCDpVZ0a/Y92Vm0Zc6Q=
-github.com/prometheus/client_golang v1.22.0/go.mod h1:R7ljNsLXhuQXYZYtw6GAE9AZg8Y7vEW5scdCXrWRXC0=
-github.com/prometheus/client_model v0.6.1 h1:ZKSh/rekM+n3CeS952MLRAdFwIKqeY8b62p8ais2e9E=
-github.com/prometheus/client_model v0.6.1/go.mod h1:OrxVMOVHjw3lKMa8+x6HeMGkHMQyHDk9E3jmP2AmGiY=
-github.com/prometheus/common v0.62.0 h1:xasJaQlnWAeyHdUBeGjXmutelfJHWMRr+Fg4QszZ2Io=
-github.com/prometheus/common v0.62.0/go.mod h1:vyBcEuLSvWos9B1+CyL7JZ2up+uFzXhkqml0W5zIY1I=
-github.com/prometheus/procfs v0.15.1 h1:YagwOFzUgYfKKHX6Dr+sHT7km/hxC76UB0learggepc=
-github.com/prometheus/procfs v0.15.1/go.mod h1:fB45yRUv8NstnjriLhBQLuOUt+WW4BsoGhij/e3PBqk=
+github.com/pmezard/go-difflib v1.0.1-0.20181226105442-5d4384ee4fb2 h1:Jamvg5psRIccs7FGNTlIRMkT8wgtp5eCXdBlqhYGL6U=
+github.com/pmezard/go-difflib v1.0.1-0.20181226105442-5d4384ee4fb2/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
+github.com/prometheus/client_golang v1.23.0 h1:ust4zpdl9r4trLY/gSjlm07PuiBq2ynaXXlptpfy8Uc=
+github.com/prometheus/client_golang v1.23.0/go.mod h1:i/o0R9ByOnHX0McrTMTyhYvKE4haaf2mW08I+jGAjEE=
+github.com/prometheus/client_model v0.6.2 h1:oBsgwpGs7iVziMvrGhE53c/GrLUsZdHnqNwqPLxwZyk=
+github.com/prometheus/client_model v0.6.2/go.mod h1:y3m2F6Gdpfy6Ut/GBsUqTWZqCUvMVzSfMLjcu6wAwpE=
+github.com/prometheus/common v0.65.0 h1:QDwzd+G1twt//Kwj/Ww6E9FQq1iVMmODnILtW1t2VzE=
+github.com/prometheus/common v0.65.0/go.mod h1:0gZns+BLRQ3V6NdaerOhMbwwRbNh9hkGINtQAsP5GS8=
+github.com/prometheus/procfs v0.17.0 h1:FuLQ+05u4ZI+SS/w9+BWEM2TXiHKsUQ9TADiRH7DuK0=
+github.com/prometheus/procfs v0.17.0/go.mod h1:oPQLaDAMRbA+u8H5Pbfq+dl3VDAvHxMUOVhe0wYB2zw=
 github.com/rogpeppe/go-internal v1.13.1 h1:KvO1DLK/DRN07sQ1LQKScxyZJuNnedQ5/wKSR38lUII=
 github.com/rogpeppe/go-internal v1.13.1/go.mod h1:uMEvuHeurkdAXX61udpOXGD/AzZDWNMNyH2VO9fmH0o=
 github.com/russross/blackfriday/v2 v2.1.0/go.mod h1:+Rmxgy9KzJVeS9/2gXHxylqXiyQDYRxCVz55jmeOWTM=
 github.com/spf13/cobra v1.9.1 h1:CXSaggrXdbHK9CF+8ywj8Amf7PBRmPCOJugH954Nnlo=
 github.com/spf13/cobra v1.9.1/go.mod h1:nDyEzZ8ogv936Cinf6g1RU9MRY64Ir93oCnqb9wxYW0=
-github.com/spf13/pflag v1.0.6 h1:jFzHGLGAlb3ruxLB8MhbI6A8+AQX/2eW4qeyNZXNp2o=
 github.com/spf13/pflag v1.0.6/go.mod h1:McXfInJRrz4CZXVZOBLb0bTZqETkiAhM9Iw0y3An2Bg=
+github.com/spf13/pflag v1.0.7 h1:vN6T9TfwStFPFM5XzjsvmzZkLuaLX+HS+0SeFLRgU6M=
+github.com/spf13/pflag v1.0.7/go.mod h1:McXfInJRrz4CZXVZOBLb0bTZqETkiAhM9Iw0y3An2Bg=
 github.com/stoewer/go-strcase v1.3.0 h1:g0eASXYtp+yvN9fK8sH94oCIk0fau9uV1/ZdJ0AVEzs=
 github.com/stoewer/go-strcase v1.3.0/go.mod h1:fAH5hQ5pehh+j3nZfvwdk2RgEgQjAoM8wodgtPmh1xo=
 github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
@@ -128,8 +125,8 @@ github.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UV
 github.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
 github.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=
 github.com/stretchr/testify v1.8.1/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=
-github.com/stretchr/testify v1.10.0 h1:Xv5erBjTwe/5IxqUQTdXv5kgmIvbHo3QQyRwhJsOfJA=
-github.com/stretchr/testify v1.10.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=
+github.com/stretchr/testify v1.11.0 h1:ib4sjIrwZKxE5u/Japgo/7SJV3PvgjGiRNAvTVGqQl8=
+github.com/stretchr/testify v1.11.0/go.mod h1:wZwfW3scLgRK+23gO65QZefKpKQRnfz6sD981Nm4B6U=
 github.com/x448/float16 v0.8.4 h1:qLwI1I70+NjRFUR3zs1JPUCgaCXSh3SW62uAKT1mSBM=
 github.com/x448/float16 v0.8.4/go.mod h1:14CWIYCyZA/cWjXOioeEpHeN/83MdbZDRQHoFcYsOfg=
 github.com/yuin/goldmark v1.1.27/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=
@@ -138,20 +135,20 @@ go.opentelemetry.io/auto/sdk v1.1.0 h1:cH53jehLUN6UFLY71z+NDOiNJqDdPRaXzTel0sJyS
 go.opentelemetry.io/auto/sdk v1.1.0/go.mod h1:3wSPjt5PWp2RhlCcmmOial7AvC4DQqZb7a7wCow3W8A=
 go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.58.0 h1:yd02MEjBdJkG3uabWP9apV+OuWRIXGDuJEUJbOHmCFU=
 go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.58.0/go.mod h1:umTcuxiv1n/s/S6/c2AT/g2CQ7u5C59sHDNmfSwgz7Q=
-go.opentelemetry.io/otel v1.35.0 h1:xKWKPxrxB6OtMCbmMY021CqC45J+3Onta9MqjhnusiQ=
-go.opentelemetry.io/otel v1.35.0/go.mod h1:UEqy8Zp11hpkUrL73gSlELM0DupHoiq72dR+Zqel/+Y=
+go.opentelemetry.io/otel v1.37.0 h1:9zhNfelUvx0KBfu/gb+ZgeAfAgtWrfHJZcAqFC228wQ=
+go.opentelemetry.io/otel v1.37.0/go.mod h1:ehE/umFRLnuLa/vSccNq9oS1ErUlkkK71gMcN34UG8I=
 go.opentelemetry.io/otel/exporters/otlp/otlptrace v1.34.0 h1:OeNbIYk/2C15ckl7glBlOBp5+WlYsOElzTNmiPW/x60=
 go.opentelemetry.io/otel/exporters/otlp/otlptrace v1.34.0/go.mod h1:7Bept48yIeqxP2OZ9/AqIpYS94h2or0aB4FypJTc8ZM=
 go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc v1.34.0 h1:tgJ0uaNS4c98WRNUEx5U3aDlrDOI5Rs+1Vifcw4DJ8U=
 go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc v1.34.0/go.mod h1:U7HYyW0zt/a9x5J1Kjs+r1f/d4ZHnYFclhYY2+YbeoE=
-go.opentelemetry.io/otel/metric v1.35.0 h1:0znxYu2SNyuMSQT4Y9WDWej0VpcsxkuklLa4/siN90M=
-go.opentelemetry.io/otel/metric v1.35.0/go.mod h1:nKVFgxBZ2fReX6IlyW28MgZojkoAkJGaE8CpgeAU3oE=
-go.opentelemetry.io/otel/sdk v1.34.0 h1:95zS4k/2GOy069d321O8jWgYsW3MzVV+KuSPKp7Wr1A=
-go.opentelemetry.io/otel/sdk v1.34.0/go.mod h1:0e/pNiaMAqaykJGKbi+tSjWfNNHMTxoC9qANsCzbyxU=
-go.opentelemetry.io/otel/sdk/metric v1.34.0 h1:5CeK9ujjbFVL5c1PhLuStg1wxA7vQv7ce1EK0Gyvahk=
-go.opentelemetry.io/otel/sdk/metric v1.34.0/go.mod h1:jQ/r8Ze28zRKoNRdkjCZxfs6YvBTG1+YIqyFVFYec5w=
-go.opentelemetry.io/otel/trace v1.35.0 h1:dPpEfJu1sDIqruz7BHFG3c7528f6ddfSWfFDVt/xgMs=
-go.opentelemetry.io/otel/trace v1.35.0/go.mod h1:WUk7DtFp1Aw2MkvqGdwiXYDZZNvA/1J8o6xRXLrIkyc=
+go.opentelemetry.io/otel/metric v1.37.0 h1:mvwbQS5m0tbmqML4NqK+e3aDiO02vsf/WgbsdpcPoZE=
+go.opentelemetry.io/otel/metric v1.37.0/go.mod h1:04wGrZurHYKOc+RKeye86GwKiTb9FKm1WHtO+4EVr2E=
+go.opentelemetry.io/otel/sdk v1.37.0 h1:ItB0QUqnjesGRvNcmAcU0LyvkVyGJ2xftD29bWdDvKI=
+go.opentelemetry.io/otel/sdk v1.37.0/go.mod h1:VredYzxUvuo2q3WRcDnKDjbdvmO0sCzOvVAiY+yUkAg=
+go.opentelemetry.io/otel/sdk/metric v1.37.0 h1:90lI228XrB9jCMuSdA0673aubgRobVZFhbjxHHspCPc=
+go.opentelemetry.io/otel/sdk/metric v1.37.0/go.mod h1:cNen4ZWfiD37l5NhS+Keb5RXVWZWpRE+9WyVCpbo5ps=
+go.opentelemetry.io/otel/trace v1.37.0 h1:HLdcFNbRQBE2imdSEgm/kwqmQj1Or1l/7bW6mxVK7z4=
+go.opentelemetry.io/otel/trace v1.37.0/go.mod h1:TlgrlQ+PtQO5XFerSPUYG0JSgGyryXewPGyayAWSBS0=
 go.opentelemetry.io/proto/otlp v1.5.0 h1:xJvq7gMzB31/d406fB8U5CBdyQGw4P399D1aQWU/3i4=
 go.opentelemetry.io/proto/otlp v1.5.0/go.mod h1:keN8WnHxOy8PG0rQZjJJ5A2ebUoafqWp0eVQ4yIXvJ4=
 go.uber.org/goleak v1.3.0 h1:2K3zAYmnTNqV73imy9J1T3WC+gmCePx2hEGkimedGto=
@@ -175,53 +172,55 @@ golang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn
 golang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
 golang.org/x/net v0.0.0-20200226121028-0de0cce0169b/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
 golang.org/x/net v0.0.0-20201021035429-f5854403a974/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=
-golang.org/x/net v0.38.0 h1:vRMAPTMaeGqVhG5QyLJHqNDwecKTomGeqbnfZyKlBI8=
-golang.org/x/net v0.38.0/go.mod h1:ivrbrMbzFq5J41QOQh0siUuly180yBYtLp+CKbEaFx8=
-golang.org/x/oauth2 v0.27.0 h1:da9Vo7/tDv5RH/7nZDz1eMGS/q1Vv1N/7FCrBhI9I3M=
-golang.org/x/oauth2 v0.27.0/go.mod h1:onh5ek6nERTohokkhCD/y2cV4Do3fxFHFuAejCkRWT8=
+golang.org/x/net v0.43.0 h1:lat02VYK2j4aLzMzecihNvTlJNQUq316m2Mr9rnM6YE=
+golang.org/x/net v0.43.0/go.mod h1:vhO1fvI4dGsIjh73sWfUVjj3N7CA9WkKJNQm2svM6Jg=
+golang.org/x/oauth2 v0.30.0 h1:dnDm7JmhM45NNpd8FDDeLhK6FwqbOf4MLCM9zb1BOHI=
+golang.org/x/oauth2 v0.30.0/go.mod h1:B++QgG3ZKulg6sRPGD/mqlHQs5rB3Ml9erfeDY7xKlU=
 golang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
 golang.org/x/sync v0.0.0-20190911185100-cd5d95a43a6e/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
 golang.org/x/sync v0.0.0-20201020160332-67f06af15bc9/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
-golang.org/x/sync v0.12.0 h1:MHc5BpPuC30uJk597Ri8TV3CNZcTLu6B6z4lJy+g6Jw=
-golang.org/x/sync v0.12.0/go.mod h1:1dzgHSNfp02xaA81J2MS99Qcpr2w7fw1gpm99rleRqA=
+golang.org/x/sync v0.16.0 h1:ycBJEhp9p4vXvUZNszeOq0kGTPghopOL8q0fq3vstxw=
+golang.org/x/sync v0.16.0/go.mod h1:1dzgHSNfp02xaA81J2MS99Qcpr2w7fw1gpm99rleRqA=
 golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
 golang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
 golang.org/x/sys v0.0.0-20200930185726-fdedc70b468f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
-golang.org/x/sys v0.31.0 h1:ioabZlmFYtWhL+TRYpcnNlLwhyxaM9kWTDEmfnprqik=
-golang.org/x/sys v0.31.0/go.mod h1:BJP2sWEmIv4KK5OTEluFJCKSidICx8ciO85XgH3Ak8k=
-golang.org/x/term v0.30.0 h1:PQ39fJZ+mfadBm0y5WlL4vlM7Sx1Hgf13sMIY2+QS9Y=
-golang.org/x/term v0.30.0/go.mod h1:NYYFdzHoI5wRh/h5tDMdMqCqPJZEuNqVR5xJLd/n67g=
+golang.org/x/sys v0.35.0 h1:vz1N37gP5bs89s7He8XuIYXpyY0+QlsKmzipCbUtyxI=
+golang.org/x/sys v0.35.0/go.mod h1:BJP2sWEmIv4KK5OTEluFJCKSidICx8ciO85XgH3Ak8k=
+golang.org/x/term v0.34.0 h1:O/2T7POpk0ZZ7MAzMeWFSg6S5IpWd/RXDlM9hgM3DR4=
+golang.org/x/term v0.34.0/go.mod h1:5jC53AEywhIVebHgPVeg0mj8OD3VO9OzclacVrqpaAw=
 golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
 golang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
-golang.org/x/text v0.23.0 h1:D71I7dUrlY+VX0gQShAThNGHFxZ13dGLBHQLVl1mJlY=
-golang.org/x/text v0.23.0/go.mod h1:/BLNzu4aZCJ1+kcD0DNRotWKage4q2rGVAg4o22unh4=
-golang.org/x/time v0.9.0 h1:EsRrnYcQiGH+5FfbgvV4AP7qEZstoyrHB0DzarOQ4ZY=
-golang.org/x/time v0.9.0/go.mod h1:3BpzKBy/shNhVucY/MWOyx10tF3SFh9QdLuxbVysPQM=
+golang.org/x/text v0.28.0 h1:rhazDwis8INMIwQ4tpjLDzUhx6RlXqZNPEM0huQojng=
+golang.org/x/text v0.28.0/go.mod h1:U8nCwOR8jO/marOQ0QbDiOngZVEBB7MAiitBuMjXiNU=
+golang.org/x/time v0.12.0 h1:ScB/8o8olJvc+CQPWrK3fPZNfh7qgwCrY0zJmoEQLSE=
+golang.org/x/time v0.12.0/go.mod h1:CDIdPxbZBQxdj6cxyCIdrNogrJKMJ7pr37NYpMcMDSg=
 golang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
 golang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
 golang.org/x/tools v0.0.0-20200619180055-7c47624df98f/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=
 golang.org/x/tools v0.0.0-20210106214847-113979e3529a/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=
-golang.org/x/tools v0.26.0 h1:v/60pFQmzmT9ExmjDv2gGIfi3OqfKoEP6I5+umXlbnQ=
-golang.org/x/tools v0.26.0/go.mod h1:TPVVj70c7JJ3WCazhD8OdXcZg/og+b9+tH/KxylGwH0=
+golang.org/x/tools v0.36.0 h1:kWS0uv/zsvHEle1LbV5LE8QujrxB3wfQyxHfhOk0Qkg=
+golang.org/x/tools v0.36.0/go.mod h1:WBDiHKJK8YgLHlcQPYQzNCkUxUypCaa5ZegCVutKm+s=
 golang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
 golang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
 golang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
 golang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
 gomodules.xyz/jsonpatch/v2 v2.4.0 h1:Ci3iUJyx9UeRx7CeFN8ARgGbkESwJK+KB9lLcWxY/Zw=
 gomodules.xyz/jsonpatch/v2 v2.4.0/go.mod h1:AH3dM2RI6uoBZxn3LVrfvJ3E0/9dG4cSrbuBJT4moAY=
-google.golang.org/genproto/googleapis/api v0.0.0-20250303144028-a0af3efb3deb h1:p31xT4yrYrSM/G4Sn2+TNUkVhFCbG9y8itM2S6Th950=
-google.golang.org/genproto/googleapis/api v0.0.0-20250303144028-a0af3efb3deb/go.mod h1:jbe3Bkdp+Dh2IrslsFCklNhweNTBgSYanP1UXhJDhKg=
-google.golang.org/genproto/googleapis/rpc v0.0.0-20250303144028-a0af3efb3deb h1:TLPQVbx1GJ8VKZxz52VAxl1EBgKXXbTiU9Fc5fZeLn4=
-google.golang.org/genproto/googleapis/rpc v0.0.0-20250303144028-a0af3efb3deb/go.mod h1:LuRYeWDFV6WOn90g357N17oMCaxpgCnbi/44qJvDn2I=
-google.golang.org/grpc v1.72.1 h1:HR03wO6eyZ7lknl75XlxABNVLLFc2PAb6mHlYh756mA=
-google.golang.org/grpc v1.72.1/go.mod h1:wH5Aktxcg25y1I3w7H69nHfXdOG3UiadoBtjh3izSDM=
-google.golang.org/protobuf v1.36.5 h1:tPhr+woSbjfYvY6/GPufUoYizxw1cF/yFoxJ2fmpwlM=
-google.golang.org/protobuf v1.36.5/go.mod h1:9fA7Ob0pmnwhb644+1+CVWFRbNajQ6iRojtC/QF5bRE=
+gonum.org/v1/gonum v0.16.0 h1:5+ul4Swaf3ESvrOnidPp4GZbzf0mxVQpDCYUQE7OJfk=
+gonum.org/v1/gonum v0.16.0/go.mod h1:fef3am4MQ93R2HHpKnLk4/Tbh/s0+wqD5nfa6Pnwy4E=
+google.golang.org/genproto/googleapis/api v0.0.0-20250707201910-8d1bb00bc6a7 h1:FiusG7LWj+4byqhbvmB+Q93B/mOxJLN2DTozDuZm4EU=
+google.golang.org/genproto/googleapis/api v0.0.0-20250707201910-8d1bb00bc6a7/go.mod h1:kXqgZtrWaf6qS3jZOCnCH7WYfrvFjkC51bM8fz3RsCA=
+google.golang.org/genproto/googleapis/rpc v0.0.0-20250826171959-ef028d996bc1 h1:pmJpJEvT846VzausCQ5d7KreSROcDqmO388w5YbnltA=
+google.golang.org/genproto/googleapis/rpc v0.0.0-20250826171959-ef028d996bc1/go.mod h1:GmFNa4BdJZ2a8G+wCe9Bg3wwThLrJun751XstdJt5Og=
+google.golang.org/grpc v1.75.1 h1:/ODCNEuf9VghjgO3rqLcfg8fiOP0nSluljWFlDxELLI=
+google.golang.org/grpc v1.75.1/go.mod h1:JtPAzKiq4v1xcAB2hydNlWI2RnF85XXcV0mhKXr2ecQ=
+google.golang.org/protobuf v1.36.8 h1:xHScyCOEuuwZEc6UtSOvPbAT4zRh0xcNRYekJwfqyMc=
+google.golang.org/protobuf v1.36.8/go.mod h1:fuxRtAxBytpl4zzqUh6/eyUujkJdNiuEkXntxiD/uRU=
 gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
 gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c h1:Hei/4ADfdWqJk1ZMxUNpqntNwaWcugrBjAiHlqqRiVk=
 gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c/go.mod h1:JHkPIbrfpd72SG/EVd6muEfDQjcINNoR0C8j2r3qZ4Q=
-gopkg.in/evanphx/json-patch.v4 v4.12.0 h1:n6jtcsulIzXPJaxegRbvFNNrZDjbij7ny3gmSPG+6V4=
-gopkg.in/evanphx/json-patch.v4 v4.12.0/go.mod h1:p8EYWUEYMpynmqDbY58zCKCFZw8pRWMG4EsWvDvM72M=
+gopkg.in/evanphx/json-patch.v4 v4.13.0 h1:czT3CmqEaQ1aanPc5SdlgQrrEIb8w/wwCvWWnfEbYzo=
+gopkg.in/evanphx/json-patch.v4 v4.13.0/go.mod h1:p8EYWUEYMpynmqDbY58zCKCFZw8pRWMG4EsWvDvM72M=
 gopkg.in/inf.v0 v0.9.1 h1:73M5CoZyi3ZLMOyDlQh031Cx6N9NDJ2Vvfl76EDAgDc=
 gopkg.in/inf.v0 v0.9.1/go.mod h1:cWUDdTG/fYaXco+Dcufb5Vnc6Gp2YChqWtbxRZE0mXw=
 gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
@@ -241,16 +240,18 @@ k8s.io/component-base v0.34.1 h1:v7xFgG+ONhytZNFpIz5/kecwD+sUhVE6HU7qQUiRM4A=
 k8s.io/component-base v0.34.1/go.mod h1:mknCpLlTSKHzAQJJnnHVKqjxR7gBeHRv0rPXA7gdtQ0=
 k8s.io/klog/v2 v2.130.1 h1:n9Xl7H1Xvksem4KFG4PYbdQCQxqc/tTUyrgXaOhHSzk=
 k8s.io/klog/v2 v2.130.1/go.mod h1:3Jpz1GvMt720eyJH1ckRHK1EDfpxISzJ7I9OYgaDtPE=
-k8s.io/kube-openapi v0.0.0-20250710124328-f3f2b991d03b h1:MloQ9/bdJyIu9lb1PzujOPolHyvO06MXG5TUIj2mNAA=
-k8s.io/kube-openapi v0.0.0-20250710124328-f3f2b991d03b/go.mod h1:UZ2yyWbFTpuhSbFhv24aGNOdoRdJZgsIObGBUaYVsts=
-k8s.io/utils v0.0.0-20250604170112-4c0f3b243397 h1:hwvWFiBzdWw1FhfY1FooPn3kzWuJ8tmbZBHi4zVsl1Y=
-k8s.io/utils v0.0.0-20250604170112-4c0f3b243397/go.mod h1:OLgZIPagt7ERELqWJFomSt595RzquPNLL48iOWgYOg0=
+k8s.io/kube-openapi v0.0.0-20250814151709-d7b6acb124c3 h1:liMHz39T5dJO1aOKHLvwaCjDbf07wVh6yaUlTpunnkE=
+k8s.io/kube-openapi v0.0.0-20250814151709-d7b6acb124c3/go.mod h1:UZ2yyWbFTpuhSbFhv24aGNOdoRdJZgsIObGBUaYVsts=
+k8s.io/utils v0.0.0-20250820121507-0af2bda4dd1d h1:wAhiDyZ4Tdtt7e46e9M5ZSAJ/MnPGPs+Ki1gHw4w1R0=
+k8s.io/utils v0.0.0-20250820121507-0af2bda4dd1d/go.mod h1:OLgZIPagt7ERELqWJFomSt595RzquPNLL48iOWgYOg0=
 sigs.k8s.io/apiserver-network-proxy/konnectivity-client v0.31.2 h1:jpcvIRr3GLoUoEKRkHKSmGjxb6lWwrBlJsXc+eUYQHM=
 sigs.k8s.io/apiserver-network-proxy/konnectivity-client v0.31.2/go.mod h1:Ve9uj1L+deCXFrPOk1LpFXqTg7LCFzFso6PA48q/XZw=
 sigs.k8s.io/controller-runtime v0.22.4 h1:GEjV7KV3TY8e+tJ2LCTxUTanW4z/FmNB7l327UfMq9A=
 sigs.k8s.io/controller-runtime v0.22.4/go.mod h1:+QX1XUpTXN4mLoblf4tqr5CQcyHPAki2HLXqQMY6vh8=
-sigs.k8s.io/json v0.0.0-20241014173422-cfa47c3a1cc8 h1:gBQPwqORJ8d8/YNZWEjoZs7npUVDpVXUUOFfW6CgAqE=
-sigs.k8s.io/json v0.0.0-20241014173422-cfa47c3a1cc8/go.mod h1:mdzfpAEoE6DHQEN0uh9ZbOCuHbLK5wOm7dK4ctXE9Tg=
+sigs.k8s.io/gateway-api v1.4.1 h1:NPxFutNkKNa8UfLd2CMlEuhIPMQgDQ6DXNKG9sHbJU8=
+sigs.k8s.io/gateway-api v1.4.1/go.mod h1:AR5RSqciWP98OPckEjOjh2XJhAe2Na4LHyXD2FUY7Qk=
+sigs.k8s.io/json v0.0.0-20250730193827-2d320260d730 h1:IpInykpT6ceI+QxKBbEflcR5EXP7sU1kvOlxwZh5txg=
+sigs.k8s.io/json v0.0.0-20250730193827-2d320260d730/go.mod h1:mdzfpAEoE6DHQEN0uh9ZbOCuHbLK5wOm7dK4ctXE9Tg=
 sigs.k8s.io/randfill v1.0.0 h1:JfjMILfT8A6RbawdsK2JXGBR5AQVfd+9TbzrlneTyrU=
 sigs.k8s.io/randfill v1.0.0/go.mod h1:XeLlZ/jmk4i1HRopwe7/aU3H5n1zNUcX6TM94b3QxOY=
 sigs.k8s.io/structured-merge-diff/v6 v6.3.0 h1:jTijUJbW353oVOd9oTlifJqOGEkUw2jB/fXCbTiQEco=
diff --git a/internal/controller/nebariapp_controller.go b/internal/controller/nebariapp_controller.go
index 8163845..bf07d2d 100644
--- a/internal/controller/nebariapp_controller.go
+++ b/internal/controller/nebariapp_controller.go
@@ -18,11 +18,13 @@ package controller
 
 import (
 	"context"
+	"fmt"
 	"time"
 
 	"k8s.io/apimachinery/pkg/api/errors"
 	"k8s.io/client-go/tools/record"
 
+	corev1 "k8s.io/api/core/v1"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/apimachinery/pkg/runtime"
 	ctrl "sigs.k8s.io/controller-runtime"
@@ -30,16 +32,21 @@ import (
 	logf "sigs.k8s.io/controller-runtime/pkg/log"
 
 	appsv1 "github.com/nebari-dev/nebari-operator/api/v1"
+	"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
+
 	"github.com/nebari-dev/nebari-operator/internal/controller/reconcilers/core"
+	"github.com/nebari-dev/nebari-operator/internal/controller/reconcilers/routing"
 	"github.com/nebari-dev/nebari-operator/internal/controller/utils/conditions"
+	"github.com/nebari-dev/nebari-operator/internal/controller/utils/constants"
 )
 
 // NebariAppReconciler reconciles a NebariApp object
 type NebariAppReconciler struct {
 	client.Client
-	Scheme         *runtime.Scheme
-	Recorder       record.EventRecorder
-	CoreReconciler *core.CoreReconciler
+	Scheme            *runtime.Scheme
+	Recorder          record.EventRecorder
+	CoreReconciler    *core.CoreReconciler
+	RoutingReconciler *routing.RoutingReconciler
 }
 
 // +kubebuilder:rbac:groups=reconcilers.nebari.dev,resources=nebariapps,verbs=get;list;watch;create;update;patch;delete
@@ -49,6 +56,10 @@ type NebariAppReconciler struct {
 // +kubebuilder:rbac:groups=core,resources=services,verbs=get;list;watch
 // +kubebuilder:rbac:groups=core,resources=secrets,verbs=get;list;watch;create;update;patch
 // +kubebuilder:rbac:groups=core,resources=events,verbs=create;patch
+// +kubebuilder:rbac:groups=gateway.networking.k8s.io,resources=httproutes,verbs=get;list;watch;create;update;patch;delete
+// +kubebuilder:rbac:groups=gateway.networking.k8s.io,resources=gateways,verbs=get;list;watch
+// +kubebuilder:rbac:groups=cert-manager.io,resources=certificates,verbs=get;list;watch;create;update;patch;delete
+// +kubebuilder:rbac:groups=gateway.envoyproxy.io,resources=securitypolicies,verbs=get;list;watch;create;update;patch;delete
 
 // Reconcile is part of the main kubernetes reconciliation loop which aims to
 // move the current state of the cluster closer to the desired state.
@@ -79,6 +90,42 @@ func (r *NebariAppReconciler) Reconcile(ctx context.Context, req ctrl.Request) (
 		}
 	}
 
+	// Initialize routing reconciler if needed
+	if r.RoutingReconciler == nil {
+		r.RoutingReconciler = &routing.RoutingReconciler{
+			Client:   r.Client,
+			Scheme:   r.Scheme,
+			Recorder: r.Recorder,
+		}
+	}
+
+	// Handle finalizer
+	if nebariApp.DeletionTimestamp.IsZero() {
+		// Object is not being deleted, ensure finalizer is present
+		if !controllerutil.ContainsFinalizer(nebariApp, constants.NebariAppFinalizer) {
+			controllerutil.AddFinalizer(nebariApp, constants.NebariAppFinalizer)
+			if err := r.Update(ctx, nebariApp); err != nil {
+				return ctrl.Result{}, err
+			}
+		}
+	} else {
+		// Object is being deleted
+		if controllerutil.ContainsFinalizer(nebariApp, constants.NebariAppFinalizer) {
+			// Run cleanup logic
+			if err := r.cleanup(ctx, nebariApp); err != nil {
+				logger.Error(err, "Failed to cleanup resources")
+				return ctrl.Result{}, err
+			}
+
+			// Remove finalizer
+			controllerutil.RemoveFinalizer(nebariApp, constants.NebariAppFinalizer)
+			if err := r.Update(ctx, nebariApp); err != nil {
+				return ctrl.Result{}, err
+			}
+		}
+		return ctrl.Result{}, nil
+	}
+
 	// Initialize status if needed
 	if nebariApp.Status.ObservedGeneration == 0 {
 		nebariApp.Status.ObservedGeneration = nebariApp.Generation
@@ -99,6 +146,28 @@ func (r *NebariAppReconciler) Reconcile(ctx context.Context, req ctrl.Request) (
 		return ctrl.Result{RequeueAfter: 5 * time.Minute}, nil
 	}
 
+	logger.Info("Core validation passed", "nebariapp", nebariApp.Name)
+	r.Recorder.Event(nebariApp, corev1.EventTypeNormal, appsv1.EventReasonValidationSuccess, "NebariApp validation completed successfully")
+
+	// Reconcile routing (HTTPRoute creation/update) if routing is configured
+	if nebariApp.Spec.Routing != nil {
+		if err := r.RoutingReconciler.ReconcileRouting(ctx, nebariApp); err != nil {
+			logger.Error(err, "Routing reconciliation failed")
+			conditions.SetCondition(nebariApp, appsv1.ConditionTypeReady, metav1.ConditionFalse,
+				appsv1.ReasonFailed, fmt.Sprintf("Routing reconciliation failed: %v", err))
+			if err := r.Status().Update(ctx, nebariApp); err != nil {
+				return ctrl.Result{}, err
+			}
+			return ctrl.Result{RequeueAfter: time.Minute}, nil
+		}
+		logger.Info("Routing reconciled successfully", "nebariapp", nebariApp.Name)
+	} else {
+		// Routing not configured - set condition to indicate routing is not enabled
+		conditions.SetCondition(nebariApp, appsv1.ConditionTypeRoutingReady, metav1.ConditionFalse,
+			"RoutingNotConfigured", "Routing configuration not provided in spec")
+		logger.Info("Routing not configured, skipping HTTPRoute reconciliation", "nebariapp", nebariApp.Name)
+	}
+
 	// Validation succeeded, set Ready condition to True
 	conditions.SetCondition(nebariApp, appsv1.ConditionTypeReady, metav1.ConditionTrue,
 		appsv1.ReasonReconcileSuccess, "NebariApp reconciled successfully")
@@ -117,6 +186,26 @@ func (r *NebariAppReconciler) Reconcile(ctx context.Context, req ctrl.Request) (
 	return ctrl.Result{RequeueAfter: time.Minute}, nil
 }
 
+// cleanup removes resources created by this NebariApp
+func (r *NebariAppReconciler) cleanup(ctx context.Context, nebariApp *appsv1.NebariApp) error {
+	logger := logf.FromContext(ctx)
+	logger.Info("Cleaning up resources for NebariApp", "name", nebariApp.Name, "namespace", nebariApp.Namespace)
+
+	r.Recorder.Event(nebariApp, corev1.EventTypeNormal, "Cleanup", "Starting resource cleanup")
+	// Delete HTTPRoute explicitly (also has ownerReferences for GC)
+	if r.RoutingReconciler != nil {
+		if err := r.RoutingReconciler.CleanupHTTPRoute(ctx, nebariApp); err != nil {
+			logger.Error(err, "Failed to delete HTTPRoute")
+			return err
+		}
+	}
+
+	// Additional cleanup handled automatically:
+
+	logger.Info("Cleanup completed")
+	return nil
+}
+
 // SetupWithManager sets up the controller with the Manager.
 func (r *NebariAppReconciler) SetupWithManager(mgr ctrl.Manager) error {
 	// Initialize the event recorder
diff --git a/internal/controller/nebariapp_controller_test.go b/internal/controller/nebariapp_controller_test.go
index e9b9753..5950bb3 100644
--- a/internal/controller/nebariapp_controller_test.go
+++ b/internal/controller/nebariapp_controller_test.go
@@ -59,8 +59,27 @@ var _ = Describe("NebariApp Controller", func() {
 				ns.Labels["nebari.dev/managed"] = "true"
 				Expect(k8sClient.Update(ctx, ns)).To(Succeed())
 
-				// Create a test service
-				service := &corev1.Service{
+				resource := &reconcilersv1.NebariApp{
+					ObjectMeta: metav1.ObjectMeta{
+						Name:      resourceName,
+						Namespace: "default",
+					},
+					Spec: reconcilersv1.NebariAppSpec{
+						Hostname: "test-app.nebari.local",
+						Service: reconcilersv1.ServiceReference{
+							Name: "test-service",
+							Port: 8080,
+						},
+					},
+				}
+				Expect(k8sClient.Create(ctx, resource)).To(Succeed())
+			}
+
+			// Always ensure test service exists
+			service := &corev1.Service{}
+			err = k8sClient.Get(ctx, types.NamespacedName{Name: "test-service", Namespace: "default"}, service)
+			if err != nil && errors.IsNotFound(err) {
+				service = &corev1.Service{
 					ObjectMeta: metav1.ObjectMeta{
 						Name:      "test-service",
 						Namespace: "default",
@@ -77,22 +96,7 @@ var _ = Describe("NebariApp Controller", func() {
 						},
 					},
 				}
-				_ = k8sClient.Create(ctx, service)
-
-				resource := &reconcilersv1.NebariApp{
-					ObjectMeta: metav1.ObjectMeta{
-						Name:      resourceName,
-						Namespace: "default",
-					},
-					Spec: reconcilersv1.NebariAppSpec{
-						Hostname: "test-app.nebari.local",
-						Service: reconcilersv1.ServiceReference{
-							Name: "test-service",
-							Port: 8080,
-						},
-					},
-				}
-				Expect(k8sClient.Create(ctx, resource)).To(Succeed())
+				Expect(k8sClient.Create(ctx, service)).To(Succeed())
 			}
 		})
 
@@ -141,6 +145,75 @@ var _ = Describe("NebariApp Controller", func() {
 			}
 			Expect(readyCondition).NotTo(BeNil())
 			Expect(readyCondition.Status).To(Equal(metav1.ConditionTrue))
+
+			// Check that RoutingReady condition is set to False (routing not configured)
+			var routingCondition *metav1.Condition
+			for i := range updatedApp.Status.Conditions {
+				if updatedApp.Status.Conditions[i].Type == "RoutingReady" {
+					routingCondition = &updatedApp.Status.Conditions[i]
+					break
+				}
+			}
+			Expect(routingCondition).NotTo(BeNil())
+			Expect(routingCondition.Status).To(Equal(metav1.ConditionFalse))
+			Expect(routingCondition.Reason).To(Equal("RoutingNotConfigured"))
+		})
+
+		It("should create HTTPRoute when routing is configured", func() {
+			By("Creating a NebariApp with routing configuration")
+			tlsEnabled := true
+			appWithRouting := &reconcilersv1.NebariApp{
+				ObjectMeta: metav1.ObjectMeta{
+					Name:      "test-with-routing",
+					Namespace: "default",
+				},
+				Spec: reconcilersv1.NebariAppSpec{
+					Hostname: "test-with-routing.nebari.local",
+					Service: reconcilersv1.ServiceReference{
+						Name: "test-service",
+						Port: 8080,
+					},
+					Routing: &reconcilersv1.RoutingConfig{
+						TLS: &reconcilersv1.RoutingTLSConfig{
+							Enabled: &tlsEnabled,
+						},
+					},
+				},
+			}
+			Expect(k8sClient.Create(ctx, appWithRouting)).To(Succeed())
+
+			By("Reconciling the resource with routing")
+			controllerReconciler := &NebariAppReconciler{
+				Client:   k8sClient,
+				Scheme:   k8sClient.Scheme(),
+				Recorder: record.NewFakeRecorder(10),
+			}
+
+			_, err := controllerReconciler.Reconcile(ctx, reconcile.Request{
+				NamespacedName: types.NamespacedName{
+					Name:      "test-with-routing",
+					Namespace: "default",
+				},
+			})
+			Expect(err).NotTo(HaveOccurred())
+
+			// Verify RoutingReady condition - might be True or have an error about Gateway
+			updatedApp := &reconcilersv1.NebariApp{}
+			err = k8sClient.Get(ctx, types.NamespacedName{Name: "test-with-routing", Namespace: "default"}, updatedApp)
+			Expect(err).NotTo(HaveOccurred())
+
+			var routingCondition *metav1.Condition
+			for i := range updatedApp.Status.Conditions {
+				if updatedApp.Status.Conditions[i].Type == "RoutingReady" {
+					routingCondition = &updatedApp.Status.Conditions[i]
+					break
+				}
+			}
+			// RoutingReady should be set (either True or False depending on Gateway availability)
+			Expect(routingCondition).NotTo(BeNil())
+
+			By("Cleaning up the test resource")
+			Expect(k8sClient.Delete(ctx, appWithRouting)).To(Succeed())
 		})
 	})
 })
diff --git a/internal/controller/reconcilers/routing/httproute.go b/internal/controller/reconcilers/routing/httproute.go
new file mode 100644
index 0000000..e759ec2
--- /dev/null
+++ b/internal/controller/reconcilers/routing/httproute.go
@@ -0,0 +1,277 @@
+/*
+Copyright 2026, OpenTeams.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package routing
+
+import (
+	"context"
+	"fmt"
+
+	corev1 "k8s.io/api/core/v1"
+	"k8s.io/apimachinery/pkg/api/errors"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/runtime"
+	"k8s.io/client-go/tools/record"
+	"sigs.k8s.io/controller-runtime/pkg/client"
+	"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
+	"sigs.k8s.io/controller-runtime/pkg/log"
+	gatewayv1 "sigs.k8s.io/gateway-api/apis/v1"
+
+	appsv1 "github.com/nebari-dev/nebari-operator/api/v1"
+	"github.com/nebari-dev/nebari-operator/internal/controller/utils/conditions"
+	"github.com/nebari-dev/nebari-operator/internal/controller/utils/constants"
+	"github.com/nebari-dev/nebari-operator/internal/controller/utils/naming"
+)
+
+// RoutingReconciler handles HTTPRoute generation and management for NebariApp resources
+type RoutingReconciler struct {
+	Client   client.Client
+	Scheme   *runtime.Scheme
+	Recorder record.EventRecorder
+}
+
+// ReconcileRouting creates or updates the HTTPRoute for a NebariApp
+func (r *RoutingReconciler) ReconcileRouting(ctx context.Context, nebariApp *appsv1.NebariApp) error {
+	logger := log.FromContext(ctx)
+
+	// Determine which gateway to use
+	gatewayName := r.getGatewayName(nebariApp)
+	logger.Info("Reconciling routing", "gateway", gatewayName, "hostname", nebariApp.Spec.Hostname)
+
+	// Verify gateway exists
+	if err := r.validateGateway(ctx, gatewayName); err != nil {
+		logger.Error(err, "Gateway validation failed")
+		r.Recorder.Event(nebariApp, corev1.EventTypeWarning, appsv1.EventReasonGatewayNotFound, err.Error())
+		conditions.SetCondition(nebariApp, appsv1.ConditionTypeRoutingReady, metav1.ConditionFalse,
+			appsv1.EventReasonGatewayNotFound, err.Error())
+		return err
+	}
+
+	// Generate desired HTTPRoute
+	desiredRoute := r.buildHTTPRoute(nebariApp, gatewayName)
+
+	// Check if HTTPRoute already exists
+	existingRoute := &gatewayv1.HTTPRoute{}
+	routeKey := client.ObjectKey{
+		Name:      desiredRoute.Name,
+		Namespace: desiredRoute.Namespace,
+	}
+
+	err := r.Client.Get(ctx, routeKey, existingRoute)
+	if err != nil {
+		if errors.IsNotFound(err) {
+			// Create new HTTPRoute
+			if err := r.Client.Create(ctx, desiredRoute); err != nil {
+				logger.Error(err, "Failed to create HTTPRoute")
+				conditions.SetCondition(nebariApp, appsv1.ConditionTypeRoutingReady, metav1.ConditionFalse,
+					"CreationFailed", fmt.Sprintf("Failed to create HTTPRoute: %v", err))
+				return err
+			}
+			logger.Info("Created HTTPRoute", "name", desiredRoute.Name)
+			r.Recorder.Event(nebariApp, corev1.EventTypeNormal, appsv1.EventReasonHTTPRouteCreated,
+				fmt.Sprintf("Created HTTPRoute %s", desiredRoute.Name))
+
+			conditions.SetCondition(nebariApp, appsv1.ConditionTypeRoutingReady, metav1.ConditionTrue,
+				"HTTPRouteCreated", "HTTPRoute created successfully")
+			return nil
+		}
+		return err
+	}
+
+	// Update existing HTTPRoute
+	existingRoute.Spec = desiredRoute.Spec
+	if err := r.Client.Update(ctx, existingRoute); err != nil {
+		logger.Error(err, "Failed to update HTTPRoute")
+		conditions.SetCondition(nebariApp, appsv1.ConditionTypeRoutingReady, metav1.ConditionFalse,
+			"UpdateFailed", fmt.Sprintf("Failed to update HTTPRoute: %v", err))
+		return err
+	}
+
+	logger.Info("Updated HTTPRoute", "name", existingRoute.Name)
+	r.Recorder.Event(nebariApp, corev1.EventTypeNormal, appsv1.EventReasonHTTPRouteUpdated,
+		fmt.Sprintf("Updated HTTPRoute %s", existingRoute.Name))
+
+	conditions.SetCondition(nebariApp, appsv1.ConditionTypeRoutingReady, metav1.ConditionTrue,
+		"HTTPRouteReady", "HTTPRoute is configured and ready")
+
+	return nil
+}
+
+// CleanupHTTPRoute removes the HTTPRoute for a NebariApp
+func (r *RoutingReconciler) CleanupHTTPRoute(ctx context.Context, nebariApp *appsv1.NebariApp) error {
+	logger := log.FromContext(ctx)
+
+	routeName := naming.HTTPRouteName(nebariApp)
+	route := &gatewayv1.HTTPRoute{}
+	routeKey := client.ObjectKey{
+		Name:      routeName,
+		Namespace: nebariApp.Namespace,
+	}
+
+	if err := r.Client.Get(ctx, routeKey, route); err != nil {
+		if errors.IsNotFound(err) {
+			// Already deleted
+			return nil
+		}
+		return err
+	}
+
+	if err := r.Client.Delete(ctx, route); err != nil {
+		logger.Error(err, "Failed to delete HTTPRoute")
+		return err
+	}
+
+	logger.Info("Deleted HTTPRoute", "name", routeName)
+	r.Recorder.Event(nebariApp, corev1.EventTypeNormal, appsv1.EventReasonHTTPRouteDeleted,
+		fmt.Sprintf("Deleted HTTPRoute %s", routeName))
+
+	return nil
+}
+
+// buildHTTPRoute generates an HTTPRoute resource from NebariApp spec
+func (r *RoutingReconciler) buildHTTPRoute(nebariApp *appsv1.NebariApp, gatewayName string) *gatewayv1.HTTPRoute {
+	routeName := naming.HTTPRouteName(nebariApp)
+	namespace := gatewayv1.Namespace(constants.GatewayNamespace)
+
+	// Determine which Gateway listener to use based on TLS configuration
+	// Default is HTTPS (TLS enabled) when TLS is not specified or when enabled is nil/true
+	sectionName := gatewayv1.SectionName("https")
+	tlsEnabled := true
+	if nebariApp.Spec.Routing != nil && nebariApp.Spec.Routing.TLS != nil && nebariApp.Spec.Routing.TLS.Enabled != nil && !*nebariApp.Spec.Routing.TLS.Enabled {
+		sectionName = gatewayv1.SectionName("http")
+		tlsEnabled = false
+	}
+
+	route := &gatewayv1.HTTPRoute{
+		ObjectMeta: metav1.ObjectMeta{
+			Name:      routeName,
+			Namespace: nebariApp.Namespace,
+			Labels: map[string]string{
+				"app.kubernetes.io/name":       "nicapp",
+				"app.kubernetes.io/instance":   nebariApp.Name,
+				"app.kubernetes.io/managed-by": "nic-operator",
+			},
+			Annotations: map[string]string{
+				"nebari.dev/tls-enabled": fmt.Sprintf("%t", tlsEnabled),
+			},
+		},
+		Spec: gatewayv1.HTTPRouteSpec{
+			CommonRouteSpec: gatewayv1.CommonRouteSpec{
+				ParentRefs: []gatewayv1.ParentReference{
+					{
+						Name:        gatewayv1.ObjectName(gatewayName),
+						Namespace:   &namespace,
+						SectionName: &sectionName,
+					},
+				},
+			},
+			Hostnames: []gatewayv1.Hostname{
+				gatewayv1.Hostname(nebariApp.Spec.Hostname),
+			},
+			Rules: r.buildHTTPRouteRules(nebariApp),
+		},
+	}
+
+	// Set owner reference for garbage collection
+	_ = controllerutil.SetControllerReference(nebariApp, route, r.Scheme)
+
+	return route
+}
+
+// buildHTTPRouteRules generates HTTPRoute rules based on NebariApp routes
+func (r *RoutingReconciler) buildHTTPRouteRules(nebariApp *appsv1.NebariApp) []gatewayv1.HTTPRouteRule {
+	// Get routes from routing config if specified
+	var routes []appsv1.RouteMatch
+	if nebariApp.Spec.Routing != nil {
+		routes = nebariApp.Spec.Routing.Routes
+	}
+
+	// Build a single rule with multiple matches (one per route)
+	// All matches route to the same backend, so we use one rule
+	// If no routes specified, we create an empty matches array. Gateway API will automatically
+	// add a default path match of "/" (PathPrefix) when matches is empty or null.
+	matches := make([]gatewayv1.HTTPRouteMatch, 0, len(routes))
+	for _, route := range routes {
+		pathType := gatewayv1.PathMatchPathPrefix
+		if route.PathType == "Exact" {
+			pathType = gatewayv1.PathMatchExact
+		}
+
+		pathValue := route.PathPrefix
+		match := gatewayv1.HTTPRouteMatch{
+			Path: &gatewayv1.HTTPPathMatch{
+				Type:  &pathType,
+				Value: &pathValue,
+			},
+		}
+		matches = append(matches, match)
+	}
+
+	return []gatewayv1.HTTPRouteRule{
+		{
+			Matches:     matches,
+			BackendRefs: r.buildBackendRefs(nebariApp),
+		},
+	}
+}
+
+// buildBackendRefs generates backend references for the HTTPRoute
+func (r *RoutingReconciler) buildBackendRefs(nebariApp *appsv1.NebariApp) []gatewayv1.HTTPBackendRef {
+	// weight := int32(100)
+	// if nebariApp.Spec.Service.Weight != nil {
+	// 	weight = *nebariApp.Spec.Service.Weight
+	// }
+
+	port := nebariApp.Spec.Service.Port
+
+	return []gatewayv1.HTTPBackendRef{
+		{
+			BackendRef: gatewayv1.BackendRef{
+				BackendObjectReference: gatewayv1.BackendObjectReference{
+					Name: gatewayv1.ObjectName(nebariApp.Spec.Service.Name),
+					Port: &port,
+				},
+				// Weight: &weight,
+			},
+		},
+	}
+}
+
+// getGatewayName returns the gateway name based on NebariApp spec
+func (r *RoutingReconciler) getGatewayName(nebariApp *appsv1.NebariApp) string {
+	if nebariApp.Spec.Gateway == "internal" {
+		return constants.InternalGatewayName
+	}
+	return constants.PublicGatewayName
+}
+
+// validateGateway checks if the specified gateway exists
+func (r *RoutingReconciler) validateGateway(ctx context.Context, gatewayName string) error {
+	gateway := &gatewayv1.Gateway{}
+	gatewayKey := client.ObjectKey{
+		Name:      gatewayName,
+		Namespace: constants.GatewayNamespace,
+	}
+
+	if err := r.Client.Get(ctx, gatewayKey, gateway); err != nil {
+		if errors.IsNotFound(err) {
+			return fmt.Errorf("gateway %s not found in namespace %s", gatewayName, constants.GatewayNamespace)
+		}
+		return fmt.Errorf("failed to get gateway: %w", err)
+	}
+
+	return nil
+}
diff --git a/internal/controller/reconcilers/routing/httproute_test.go b/internal/controller/reconcilers/routing/httproute_test.go
new file mode 100644
index 0000000..d20459c
--- /dev/null
+++ b/internal/controller/reconcilers/routing/httproute_test.go
@@ -0,0 +1,524 @@
+/*
+Copyright 2026, OpenTeams.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package routing
+
+import (
+	"context"
+	"testing"
+
+	corev1 "k8s.io/api/core/v1"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/runtime"
+	"k8s.io/client-go/tools/record"
+	"sigs.k8s.io/controller-runtime/pkg/client/fake"
+	gatewayv1 "sigs.k8s.io/gateway-api/apis/v1"
+
+	appsv1 "github.com/nebari-dev/nebari-operator/api/v1"
+	"github.com/nebari-dev/nebari-operator/internal/controller/utils/constants"
+)
+
+func TestValidateGateway(t *testing.T) {
+	scheme := runtime.NewScheme()
+	_ = gatewayv1.Install(scheme)
+
+	tests := []struct {
+		name        string
+		gateway     *gatewayv1.Gateway
+		gatewayName string
+		expectError bool
+	}{
+		{
+			name: "Gateway exists",
+			gateway: &gatewayv1.Gateway{
+				ObjectMeta: metav1.ObjectMeta{
+					Name:      constants.PublicGatewayName,
+					Namespace: constants.GatewayNamespace,
+				},
+			},
+			gatewayName: constants.PublicGatewayName,
+			expectError: false,
+		},
+		{
+			name:        "Gateway not found",
+			gateway:     nil,
+			gatewayName: constants.PublicGatewayName,
+			expectError: true,
+		},
+	}
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			builder := fake.NewClientBuilder().WithScheme(scheme)
+			if tt.gateway != nil {
+				builder = builder.WithObjects(tt.gateway)
+			}
+			client := builder.Build()
+
+			reconciler := &RoutingReconciler{
+				Client:   client,
+				Scheme:   scheme,
+				Recorder: record.NewFakeRecorder(10),
+			}
+
+			err := reconciler.validateGateway(context.Background(), tt.gatewayName)
+			if (err != nil) != tt.expectError {
+				t.Errorf("expected error=%v, got error=%v", tt.expectError, err)
+			}
+		})
+	}
+}
+
+func TestGetGatewayName(t *testing.T) {
+	scheme := runtime.NewScheme()
+	_ = appsv1.AddToScheme(scheme)
+
+	reconciler := &RoutingReconciler{
+		Scheme: scheme,
+	}
+
+	tests := []struct {
+		name            string
+		nebariApp       *appsv1.NebariApp
+		expectedGateway string
+	}{
+		{
+			name: "Public gateway (default)",
+			nebariApp: &appsv1.NebariApp{
+				Spec: appsv1.NebariAppSpec{
+					Gateway: "public",
+				},
+			},
+			expectedGateway: constants.PublicGatewayName,
+		},
+		{
+			name: "Public gateway (empty)",
+			nebariApp: &appsv1.NebariApp{
+				Spec: appsv1.NebariAppSpec{
+					Gateway: "",
+				},
+			},
+			expectedGateway: constants.PublicGatewayName,
+		},
+		{
+			name: "Internal gateway",
+			nebariApp: &appsv1.NebariApp{
+				Spec: appsv1.NebariAppSpec{
+					Gateway: "internal",
+				},
+			},
+			expectedGateway: constants.InternalGatewayName,
+		},
+	}
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			gatewayName := reconciler.getGatewayName(tt.nebariApp)
+			if gatewayName != tt.expectedGateway {
+				t.Errorf("expected gateway=%s, got gateway=%s", tt.expectedGateway, gatewayName)
+			}
+		})
+	}
+}
+
+func TestBuildHTTPRoute(t *testing.T) {
+	scheme := runtime.NewScheme()
+	_ = appsv1.AddToScheme(scheme)
+	_ = gatewayv1.Install(scheme)
+
+	reconciler := &RoutingReconciler{
+		Scheme:   scheme,
+		Recorder: record.NewFakeRecorder(10),
+	}
+
+	tests := []struct {
+		name                string
+		nebariApp           *appsv1.NebariApp
+		gatewayName         string
+		expectedHostname    string
+		expectedBackendPort int32
+		expectedRulesCount  int
+	}{
+		{
+			name: "Basic HTTPRoute without custom routes",
+			nebariApp: &appsv1.NebariApp{
+				ObjectMeta: metav1.ObjectMeta{
+					Name:      "test-app",
+					Namespace: "default",
+				},
+				Spec: appsv1.NebariAppSpec{
+					Hostname: "test.nebari.local",
+					Service: appsv1.ServiceReference{
+						Name: "test-service",
+						Port: 8080,
+					},
+				},
+			},
+			gatewayName:         constants.PublicGatewayName,
+			expectedHostname:    "test.nebari.local",
+			expectedBackendPort: 8080,
+			expectedRulesCount:  1,
+		},
+		{
+			name: "HTTPRoute with custom routes",
+			nebariApp: &appsv1.NebariApp{
+				ObjectMeta: metav1.ObjectMeta{
+					Name:      "test-app",
+					Namespace: "default",
+				},
+				Spec: appsv1.NebariAppSpec{
+					Hostname: "test.nebari.local",
+					Service: appsv1.ServiceReference{
+						Name: "test-service",
+						Port: 8080,
+					},
+					Routing: &appsv1.RoutingConfig{
+						Routes: []appsv1.RouteMatch{
+							{
+								PathPrefix: "/api",
+								PathType:   "PathPrefix",
+							},
+							{
+								PathPrefix: "/app",
+								PathType:   "Exact",
+							},
+						},
+					},
+				},
+			},
+			gatewayName:         constants.PublicGatewayName,
+			expectedHostname:    "test.nebari.local",
+			expectedBackendPort: 8080,
+			expectedRulesCount:  1, // Single rule with multiple matches
+		},
+	}
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			route := reconciler.buildHTTPRoute(tt.nebariApp, tt.gatewayName)
+
+			// Check basic metadata
+			if route.Name == "" {
+				t.Error("HTTPRoute name should not be empty")
+			}
+			if route.Namespace != tt.nebariApp.Namespace {
+				t.Errorf("expected namespace=%s, got namespace=%s", tt.nebariApp.Namespace, route.Namespace)
+			}
+
+			// Check parent refs
+			if len(route.Spec.ParentRefs) != 1 {
+				t.Errorf("expected 1 parent ref, got %d", len(route.Spec.ParentRefs))
+			} else {
+				if string(route.Spec.ParentRefs[0].Name) != tt.gatewayName {
+					t.Errorf("expected gateway=%s, got gateway=%s", tt.gatewayName, route.Spec.ParentRefs[0].Name)
+				}
+				if string(*route.Spec.ParentRefs[0].Namespace) != constants.GatewayNamespace {
+					t.Errorf("expected namespace=%s, got namespace=%s", constants.GatewayNamespace, *route.Spec.ParentRefs[0].Namespace)
+				}
+			}
+
+			// Check hostnames
+			if len(route.Spec.Hostnames) != 1 {
+				t.Errorf("expected 1 hostname, got %d", len(route.Spec.Hostnames))
+			} else {
+				if string(route.Spec.Hostnames[0]) != tt.expectedHostname {
+					t.Errorf("expected hostname=%s, got hostname=%s", tt.expectedHostname, route.Spec.Hostnames[0])
+				}
+			}
+
+			// Check rules count
+			if len(route.Spec.Rules) != tt.expectedRulesCount {
+				t.Errorf("expected %d rules, got %d", tt.expectedRulesCount, len(route.Spec.Rules))
+			}
+
+			// Check backend refs
+			for i, rule := range route.Spec.Rules {
+				if len(rule.BackendRefs) != 1 {
+					t.Errorf("rule %d: expected 1 backend ref, got %d", i, len(rule.BackendRefs))
+				} else {
+					backend := rule.BackendRefs[0]
+					if string(backend.Name) != tt.nebariApp.Spec.Service.Name {
+						t.Errorf("rule %d: expected backend name=%s, got=%s", i, tt.nebariApp.Spec.Service.Name, backend.Name)
+					}
+					if *backend.Port != tt.expectedBackendPort {
+						t.Errorf("rule %d: expected backend port=%d, got=%d", i, tt.expectedBackendPort, *backend.Port)
+					}
+				}
+			}
+		})
+	}
+}
+
+func TestBuildHTTPRouteRules(t *testing.T) {
+	scheme := runtime.NewScheme()
+	_ = appsv1.AddToScheme(scheme)
+
+	reconciler := &RoutingReconciler{
+		Scheme: scheme,
+	}
+
+	tests := []struct {
+		name                 string
+		nebariApp            *appsv1.NebariApp
+		expectedRulesCount   int
+		expectedMatchesCount int
+		checkPathType        bool
+		expectedPathType     gatewayv1.PathMatchType
+	}{
+		{
+			name: "Default route (no routes specified)",
+			nebariApp: &appsv1.NebariApp{
+				Spec: appsv1.NebariAppSpec{
+					Service: appsv1.ServiceReference{
+						Name: "test-service",
+						Port: 8080,
+					},
+				},
+			},
+			expectedRulesCount:   1,
+			expectedMatchesCount: 0, // Empty matches - Gateway API will add default "/" path
+			checkPathType:        false,
+			expectedPathType:     gatewayv1.PathMatchPathPrefix, // Not checked when checkPathType=false
+		},
+		{
+			name: "Multiple custom routes with different path types",
+			nebariApp: &appsv1.NebariApp{
+				Spec: appsv1.NebariAppSpec{
+					Service: appsv1.ServiceReference{
+						Name: "test-service",
+						Port: 8080,
+					},
+					Routing: &appsv1.RoutingConfig{
+						Routes: []appsv1.RouteMatch{
+							{
+								PathPrefix: "/api",
+								PathType:   "PathPrefix",
+							},
+							{
+								PathPrefix: "/exact-path",
+								PathType:   "Exact",
+							},
+						},
+					},
+				},
+			},
+			expectedRulesCount:   1, // Single rule with multiple matches
+			expectedMatchesCount: 2,
+			checkPathType:        false,
+		},
+	}
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			rules := reconciler.buildHTTPRouteRules(tt.nebariApp)
+
+			if len(rules) != tt.expectedRulesCount {
+				t.Errorf("expected %d rules, got %d", tt.expectedRulesCount, len(rules))
+			}
+
+			// Check matches count for first rule
+			if len(rules) > 0 {
+				if len(rules[0].Matches) != tt.expectedMatchesCount {
+					t.Errorf("expected %d matches in first rule, got %d", tt.expectedMatchesCount, len(rules[0].Matches))
+				}
+			}
+
+			if tt.checkPathType && len(rules) > 0 {
+				if len(rules[0].Matches) > 0 && rules[0].Matches[0].Path != nil {
+					if *rules[0].Matches[0].Path.Type != tt.expectedPathType {
+						t.Errorf("expected path type=%s, got=%s", tt.expectedPathType, *rules[0].Matches[0].Path.Type)
+					}
+				}
+			}
+
+			// Verify all rules have backend refs
+			for i, rule := range rules {
+				if len(rule.BackendRefs) == 0 {
+					t.Errorf("rule %d: expected backend refs, got none", i)
+				}
+			}
+		})
+	}
+}
+
+func TestReconcileRouting(t *testing.T) {
+	scheme := runtime.NewScheme()
+	_ = appsv1.AddToScheme(scheme)
+	_ = gatewayv1.Install(scheme)
+	_ = corev1.AddToScheme(scheme)
+
+	tests := []struct {
+		name              string
+		gateway           *gatewayv1.Gateway
+		existingRoute     *gatewayv1.HTTPRoute
+		nebariApp         *appsv1.NebariApp
+		expectError       bool
+		expectRouteCreate bool
+		expectRouteUpdate bool
+	}{
+		{
+			name: "Create new HTTPRoute",
+			gateway: &gatewayv1.Gateway{
+				ObjectMeta: metav1.ObjectMeta{
+					Name:      constants.PublicGatewayName,
+					Namespace: constants.GatewayNamespace,
+				},
+			},
+			existingRoute: nil,
+			nebariApp: &appsv1.NebariApp{
+				ObjectMeta: metav1.ObjectMeta{
+					Name:      "test-app",
+					Namespace: "default",
+				},
+				Spec: appsv1.NebariAppSpec{
+					Hostname: "test.nebari.local",
+					Service: appsv1.ServiceReference{
+						Name: "test-service",
+						Port: 8080,
+					},
+				},
+			},
+			expectError:       false,
+			expectRouteCreate: true,
+			expectRouteUpdate: false,
+		},
+		{
+			name:    "Gateway not found",
+			gateway: nil,
+			nebariApp: &appsv1.NebariApp{
+				ObjectMeta: metav1.ObjectMeta{
+					Name:      "test-app",
+					Namespace: "default",
+				},
+				Spec: appsv1.NebariAppSpec{
+					Hostname: "test.nebari.local",
+					Service: appsv1.ServiceReference{
+						Name: "test-service",
+						Port: 8080,
+					},
+				},
+			},
+			expectError:       true,
+			expectRouteCreate: false,
+			expectRouteUpdate: false,
+		},
+	}
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			builder := fake.NewClientBuilder().
+				WithScheme(scheme).
+				WithObjects(tt.nebariApp)
+
+			if tt.gateway != nil {
+				builder = builder.WithObjects(tt.gateway)
+			}
+			if tt.existingRoute != nil {
+				builder = builder.WithObjects(tt.existingRoute)
+			}
+
+			client := builder.Build()
+			reconciler := &RoutingReconciler{
+				Client:   client,
+				Scheme:   scheme,
+				Recorder: record.NewFakeRecorder(10),
+			}
+
+			err := reconciler.ReconcileRouting(context.Background(), tt.nebariApp)
+			if (err != nil) != tt.expectError {
+				t.Errorf("expected error=%v, got error=%v", tt.expectError, err)
+			}
+
+			if !tt.expectError {
+				// Verify condition was set
+				var foundCondition bool
+				for _, cond := range tt.nebariApp.Status.Conditions {
+					if cond.Type == appsv1.ConditionTypeRoutingReady {
+						foundCondition = true
+						break
+					}
+				}
+				if !foundCondition {
+					t.Error("expected RoutingReady condition to be set")
+				}
+			}
+		})
+	}
+}
+
+func TestCleanupHTTPRoute(t *testing.T) {
+	scheme := runtime.NewScheme()
+	_ = appsv1.AddToScheme(scheme)
+	_ = gatewayv1.Install(scheme)
+
+	tests := []struct {
+		name          string
+		existingRoute *gatewayv1.HTTPRoute
+		nebariApp     *appsv1.NebariApp
+		expectError   bool
+	}{
+		{
+			name: "Delete existing HTTPRoute",
+			existingRoute: &gatewayv1.HTTPRoute{
+				ObjectMeta: metav1.ObjectMeta{
+					Name:      "test-app-route",
+					Namespace: "default",
+				},
+			},
+			nebariApp: &appsv1.NebariApp{
+				ObjectMeta: metav1.ObjectMeta{
+					Name:      "test-app",
+					Namespace: "default",
+				},
+			},
+			expectError: false,
+		},
+		{
+			name:          "HTTPRoute already deleted",
+			existingRoute: nil,
+			nebariApp: &appsv1.NebariApp{
+				ObjectMeta: metav1.ObjectMeta{
+					Name:      "test-app",
+					Namespace: "default",
+				},
+			},
+			expectError: false,
+		},
+	}
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			builder := fake.NewClientBuilder().
+				WithScheme(scheme).
+				WithObjects(tt.nebariApp)
+			if tt.existingRoute != nil {
+				builder = builder.WithObjects(tt.existingRoute)
+			}
+
+			client := builder.Build()
+			reconciler := &RoutingReconciler{
+				Client:   client,
+				Scheme:   scheme,
+				Recorder: record.NewFakeRecorder(10),
+			}
+
+			err := reconciler.CleanupHTTPRoute(context.Background(), tt.nebariApp)
+			if (err != nil) != tt.expectError {
+				t.Errorf("expected error=%v, got error=%v", tt.expectError, err)
+			}
+		})
+	}
+}
diff --git a/internal/controller/utils/constants/constants.go b/internal/controller/utils/constants/constants.go
index 39419c5..ea8ad9d 100644
--- a/internal/controller/utils/constants/constants.go
+++ b/internal/controller/utils/constants/constants.go
@@ -17,15 +17,24 @@ limitations under the License.
 package constants
 
 // Gateway configuration constants
+// These match the foundational infrastructure setup via ArgoCD
 const (
 	// PublicGatewayName is the name of the public-facing gateway
-	PublicGatewayName = "nebari-public-gateway"
+	// Corresponds to the nebari-gateway Gateway resource in envoy-gateway-system
+	PublicGatewayName = "nebari-gateway"
 
-	// InternalGatewayName is the name of the internal gateway
+	// InternalGatewayName is the name of the internal gateway (if deployed)
 	InternalGatewayName = "nebari-internal-gateway"
 
 	// GatewayNamespace is the namespace where gateways are deployed
 	GatewayNamespace = "envoy-gateway-system"
+
+	// GatewayClassName is the GatewayClass used by the gateway
+	GatewayClassName = "envoy-gateway"
+
+	// DefaultTLSSecretName is the wildcard certificate used by the gateway
+	// This corresponds to the nebari-gateway-tls secret created by cert-manager
+	DefaultTLSSecretName = "nebari-gateway-tls"
 )
 
 // Resource naming suffixes
diff --git a/internal/controller/utils/constants/constants_test.go b/internal/controller/utils/constants/constants_test.go
new file mode 100644
index 0000000..eae71ab
--- /dev/null
+++ b/internal/controller/utils/constants/constants_test.go
@@ -0,0 +1,81 @@
+/*
+Copyright 2026, OpenTeams.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package constants
+
+import "testing"
+
+// TestConstants verifies that all package constants are defined and non-empty
+func TestConstants(t *testing.T) {
+	tests := []struct {
+		name  string
+		value string
+	}{
+		{"PublicGatewayName", PublicGatewayName},
+		{"InternalGatewayName", InternalGatewayName},
+		{"GatewayNamespace", GatewayNamespace},
+		{"GatewayClassName", GatewayClassName},
+		{"DefaultTLSSecretName", DefaultTLSSecretName},
+		{"HTTPRouteSuffix", HTTPRouteSuffix},
+		{"SecurityPolicySuffix", SecurityPolicySuffix},
+		{"CertificateSuffix", CertificateSuffix},
+		{"ClientSecretSuffix", ClientSecretSuffix},
+		{"ClientSecretKey", ClientSecretKey},
+		{"NebariAppFinalizer", NebariAppFinalizer},
+	}
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			if tt.value == "" {
+				t.Errorf("%s is empty", tt.name)
+			}
+		})
+	}
+}
+
+// TestGatewayConstants verifies gateway-related constants
+func TestGatewayConstants(t *testing.T) {
+	if PublicGatewayName != "nebari-gateway" {
+		t.Errorf("PublicGatewayName = %q, want %q", PublicGatewayName, "nebari-gateway")
+	}
+
+	if GatewayNamespace != "envoy-gateway-system" {
+		t.Errorf("GatewayNamespace = %q, want %q", GatewayNamespace, "envoy-gateway-system")
+	}
+
+	if GatewayClassName != "envoy-gateway" {
+		t.Errorf("GatewayClassName = %q, want %q", GatewayClassName, "envoy-gateway")
+	}
+}
+
+// TestResourceSuffixes verifies resource naming suffixes
+func TestResourceSuffixes(t *testing.T) {
+	if HTTPRouteSuffix != "route" {
+		t.Errorf("HTTPRouteSuffix = %q, want %q", HTTPRouteSuffix, "route")
+	}
+
+	if SecurityPolicySuffix != "security" {
+		t.Errorf("SecurityPolicySuffix = %q, want %q", SecurityPolicySuffix, "security")
+	}
+
+	if CertificateSuffix != "cert" {
+		t.Errorf("CertificateSuffix = %q, want %q", CertificateSuffix, "cert")
+	}
+
+	if ClientSecretSuffix != "oidc-client" {
+		t.Errorf("ClientSecretSuffix = %q, want %q", ClientSecretSuffix, "oidc-client")
+	}
+}
diff --git a/internal/controller/utils/naming/naming.go b/internal/controller/utils/naming/naming.go
new file mode 100644
index 0000000..af62759
--- /dev/null
+++ b/internal/controller/utils/naming/naming.go
@@ -0,0 +1,30 @@
+package naming
+
+import (
+	"fmt"
+
+	appsv1 "github.com/nebari-dev/nebari-operator/api/v1"
+)
+
+// ResourceName generates a consistent resource name for NebariApp-owned resources.
+// Pattern: <nicapp-name>-<resource-type>
+//
+// Examples:
+//   - ResourceName(nebariApp, "route") -> "my-app-route"
+//   - ResourceName(nebariApp, "security") -> "my-app-security"
+//   - ResourceName(nebariApp, "certificate") -> "my-app-certificate"
+func ResourceName(nebariApp *appsv1.NebariApp, resourceType string) string {
+	return fmt.Sprintf("%s-%s", nebariApp.Name, resourceType)
+}
+
+// SecurityPolicyName generates the name for a SecurityPolicy.
+// Pattern: <nicapp-name>-security
+func SecurityPolicyName(nebariApp *appsv1.NebariApp) string {
+	return ResourceName(nebariApp, "security")
+}
+
+// HTTPRouteName generates the name for an HTTPRoute.
+// Pattern: <nicapp-name>-route
+func HTTPRouteName(nebariApp *appsv1.NebariApp) string {
+	return ResourceName(nebariApp, "route")
+}
diff --git a/internal/controller/utils/naming/naming_test.go b/internal/controller/utils/naming/naming_test.go
new file mode 100644
index 0000000..617e2fd
--- /dev/null
+++ b/internal/controller/utils/naming/naming_test.go
@@ -0,0 +1,82 @@
+/*
+Copyright 2026, OpenTeams.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package naming
+
+import (
+	"testing"
+
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+
+	appsv1 "github.com/nebari-dev/nebari-operator/api/v1"
+)
+
+func TestResourceName(t *testing.T) {
+	nebariApp := &appsv1.NebariApp{
+		ObjectMeta: metav1.ObjectMeta{
+			Name: "test-app",
+		},
+	}
+
+	tests := []struct {
+		name         string
+		resourceType string
+		expected     string
+	}{
+		{"route resource", "route", "test-app-route"},
+		{"security resource", "security", "test-app-security"},
+		{"certificate resource", "certificate", "test-app-certificate"},
+	}
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			result := ResourceName(nebariApp, tt.resourceType)
+			if result != tt.expected {
+				t.Errorf("ResourceName(%q) = %q, want %q", tt.resourceType, result, tt.expected)
+			}
+		})
+	}
+}
+
+func TestSecurityPolicyName(t *testing.T) {
+	nebariApp := &appsv1.NebariApp{
+		ObjectMeta: metav1.ObjectMeta{
+			Name: "my-app",
+		},
+	}
+
+	expected := "my-app-security"
+	result := SecurityPolicyName(nebariApp)
+
+	if result != expected {
+		t.Errorf("SecurityPolicyName() = %q, want %q", result, expected)
+	}
+}
+
+func TestHTTPRouteName(t *testing.T) {
+	nebariApp := &appsv1.NebariApp{
+		ObjectMeta: metav1.ObjectMeta{
+			Name: "my-app",
+		},
+	}
+
+	expected := "my-app-route"
+	result := HTTPRouteName(nebariApp)
+
+	if result != expected {
+		t.Errorf("HTTPRouteName() = %q, want %q", result, expected)
+	}
+}
diff --git a/test/e2e/README.md b/test/e2e/README.md
new file mode 100644
index 0000000..a1a8e89
--- /dev/null
+++ b/test/e2e/README.md
@@ -0,0 +1,184 @@
+# E2E Tests
+
+End-to-end tests for the NIC Operator.
+
+## Running Tests
+
+### Option 1: Use Pre-configured Environment (Recommended)
+
+Setup infrastructure first, then run tests:
+
+```bash
+# Setup infrastructure
+cd dev
+make setup
+
+# Run tests
+cd ..
+make test-e2e USE_EXISTING_CLUSTER=true
+```
+
+### Option 2: Let Tests Setup Infrastructure
+
+Tests will create cluster and install services:
+
+```bash
+make test-e2e SETUP_INFRASTRUCTURE=true
+```
+
+### Option 3: Completely Managed (CI)
+
+Tests manage everything including cleanup:
+
+```bash
+make test-e2e
+```
+
+## Environment Variables
+
+- `USE_EXISTING_CLUSTER=true`: Use existing cluster, don't create/delete Kind cluster
+- `SETUP_INFRASTRUCTURE=true`: Run `dev/install-services.sh` to setup Envoy Gateway, cert-manager, etc.
+- `SKIP_SETUP=true`: Skip all setup, assume cluster and infrastructure exist
+
+## Test Structure
+
+### Infrastructure Validation Tests
+
+Tests that verify the foundational infrastructure is properly configured:
+
+- **Gateway and cert-manager Integration**: Validates Gateway API resources, GatewayClass, wildcard TLS certificate
+- Skipped if Gateway API CRDs not found
+
+### NebariApp Reconciliation Tests
+
+Tests that validate the operator's core functionality:
+
+- Create NebariApp resources
+- Verify HTTPRoute creation and configuration
+- Validate routing to backend services
+- Test deletion and cleanup
+
+### Routing Schema Variation Tests
+
+Comprehensive tests covering all routing schema variations (**NEW**):
+
+- **TLS Configuration**: HTTP vs HTTPS listeners, default TLS behavior
+- **Path-Based Routing**: PathPrefix and Exact match types, multiple path rules
+- **Combined Scenarios**: TLS + path routing combinations
+- **Hostname Variations**: Different hostname formats
+- **Edge Cases**: No routing config, TLS-only, root path, etc.
+
+See [ROUTING_TEST_COVERAGE.md](./ROUTING_TEST_COVERAGE.md) for detailed test coverage matrix.
+
+### HTTP/HTTPS Connectivity Tests
+
+End-to-end connectivity tests:
+
+- HTTP connectivity via Gateway IP
+- HTTPS connectivity with TLS via Gateway IP
+- Response validation
+
+## Prerequisites
+
+The tests assume the following infrastructure exists:
+
+1. **Gateway API CRDs**: Installed by Envoy Gateway
+2. **Envoy Gateway**: Running in `envoy-gateway-system` namespace
+3. **cert-manager**: With Gateway API support enabled
+4. **Gateway Resource**: `nebari-gateway` in `envoy-gateway-system`
+   - HTTP listener on port 80
+   - HTTPS listener on port 443
+   - Wildcard TLS certificate
+5. **GatewayClass**: `envoy-gateway` (created by Envoy Gateway)
+
+## Local Development Workflow
+
+1. **Setup once**:
+   ```bash
+   cd dev
+   make setup
+   cd ..
+   ```
+
+2. **Iterate on operator code**:
+   ```bash
+   # Make changes to operator...
+
+   # Run tests against existing infrastructure
+   make test-e2e USE_EXISTING_CLUSTER=true
+   ```
+
+3. **Cleanup when done**:
+   ```bash
+   cd dev
+   make teardown
+   cd ..
+   ```
+
+## CI Workflow
+
+CI should use the automatic setup mode:
+
+```yaml
+- name: Run E2E Tests
+  run: |
+    make test-e2e SETUP_INFRASTRUCTURE=true
+```
+
+This will:
+1. Create Kind cluster (if needed)
+2. Install foundational services via dev scripts
+3. Build and deploy operator
+4. Run all tests
+5. Cleanup everything
+
+## Troubleshooting
+
+### Tests are skipped
+
+If you see "Gateway API CRDs not installed - skipping tests", the infrastructure is missing:
+
+```bash
+# Check what's installed
+cd dev
+make status
+
+# Install infrastructure
+make services-install
+```
+
+### Gateway not found
+
+Verify the Gateway exists:
+
+```bash
+kubectl get gateway nebari-gateway -n envoy-gateway-system
+```
+
+If missing, reinstall services:
+
+```bash
+cd dev
+make services-install
+```
+
+### Operator not deploying
+
+Check the operator deployment:
+
+```bash
+kubectl get pods -n nebari-operator-system
+kubectl logs -n nebari-operator-system deployment/nebari-operator-controller-manager
+```
+
+### Clean slate
+
+Delete and recreate everything:
+
+```bash
+cd dev
+make teardown
+make setup
+cd ..
+make test-e2e USE_EXISTING_CLUSTER=true
+```
diff --git a/test/e2e/connectivity_test.go b/test/e2e/connectivity_test.go
new file mode 100644
index 0000000..513c3b5
--- /dev/null
+++ b/test/e2e/connectivity_test.go
@@ -0,0 +1,278 @@
+//go:build e2e
+// +build e2e
+
+/*
+Copyright 2026, OpenTeams.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package e2e
+
+import (
+	"fmt"
+	"os/exec"
+	"strings"
+	"time"
+
+	. "github.com/onsi/ginkgo/v2"
+	. "github.com/onsi/gomega"
+
+	"github.com/nebari-dev/nebari-operator/test/utils"
+)
+
+var _ = Describe("HTTPRoute Connectivity", Ordered, func() {
+	var testNamespace string
+	var gatewayIP string
+
+	BeforeAll(func() {
+		var err error
+
+		testNamespace = "e2e-test-connectivity"
+
+		By("installing NebariApp CRDs")
+		cmd := exec.Command("make", "install")
+		_, err = utils.Run(cmd)
+		Expect(err).NotTo(HaveOccurred(), "Failed to install CRDs")
+
+		By("checking if Gateway exists")
+		cmd = exec.Command("kubectl", "get", "gateway", "nebari-gateway", "-n", "envoy-gateway-system")
+		_, err = utils.Run(cmd)
+		if err != nil {
+			Skip("Gateway 'nebari-gateway' not found - run 'make setup' in dev/ first")
+		}
+
+		By("getting Gateway LoadBalancer IP")
+		cmd = exec.Command("kubectl", "get", "svc", "-n", "envoy-gateway-system",
+			"-l", "gateway.envoyproxy.io/owning-gateway-name=nebari-gateway",
+			"-o", "jsonpath={.items[0].status.loadBalancer.ingress[0].ip}")
+		gatewayIP, err = utils.Run(cmd)
+		Expect(err).NotTo(HaveOccurred(), "Failed to get Gateway IP")
+		Expect(gatewayIP).NotTo(BeEmpty(), "Gateway IP is empty")
+
+		By(fmt.Sprintf("Gateway IP: %s", gatewayIP))
+
+		By("creating test namespace")
+		cmd = exec.Command("kubectl", "create", "namespace", testNamespace, "--dry-run=client", "-o", "yaml")
+		output, err := utils.Run(cmd)
+		Expect(err).NotTo(HaveOccurred())
+
+		cmd = exec.Command("kubectl", "apply", "-f", "-")
+		cmd.Stdin = strings.NewReader(output)
+		_, err = utils.Run(cmd)
+		Expect(err).NotTo(HaveOccurred(), "Failed to create namespace")
+
+		By("labeling namespace for Operator management")
+		cmd = exec.Command("kubectl", "label", "namespace", testNamespace, "nebari.dev/managed=true", "--overwrite")
+		_, err = utils.Run(cmd)
+		Expect(err).NotTo(HaveOccurred(), "Failed to label namespace")
+
+		By("deploying the controller-manager")
+		cmd = exec.Command("make", "deploy", fmt.Sprintf("IMG=%s", projectImage))
+		_, err = utils.Run(cmd)
+		Expect(err).NotTo(HaveOccurred(), "Failed to deploy the controller-manager")
+
+		By("waiting for controller-manager to be ready")
+		Eventually(func(g Gomega) {
+			cmd := exec.Command("kubectl", "get", "deployment", "nebari-operator-controller-manager",
+				"-n", "nebari-operator-system", "-o", "jsonpath={.status.availableReplicas}")
+			output, err := utils.Run(cmd)
+			g.Expect(err).NotTo(HaveOccurred())
+			g.Expect(output).To(Equal("1"))
+		}, 2*time.Minute, time.Second).Should(Succeed())
+
+		By("creating a test application deployment")
+		appYAML, err := utils.LoadTestDataFile("test-app.yaml", map[string]string{
+			"NAMESPACE_PLACEHOLDER": testNamespace,
+		})
+		Expect(err).NotTo(HaveOccurred(), "Failed to load test-app.yaml")
+
+		cmd = exec.Command("kubectl", "apply", "-f", "-")
+		cmd.Stdin = strings.NewReader(appYAML)
+		_, err = utils.Run(cmd)
+		Expect(err).NotTo(HaveOccurred(), "Failed to create test application")
+
+		By("waiting for test application to be ready")
+		Eventually(func(g Gomega) {
+			cmd := exec.Command("kubectl", "get", "deployment", "test-app", "-n", testNamespace,
+				"-o", "jsonpath={.status.availableReplicas}")
+			output, err := utils.Run(cmd)
+			g.Expect(err).NotTo(HaveOccurred())
+			g.Expect(output).To(Equal("1"))
+		}, 2*time.Minute, time.Second).Should(Succeed())
+	})
+
+	AfterAll(func() {
+		By("cleaning up test resources")
+		cmd := exec.Command("kubectl", "delete", "namespace", testNamespace, "--ignore-not-found", "--timeout=60s")
+		_, _ = utils.Run(cmd)
+
+		By("undeploying the controller-manager")
+		cmd = exec.Command("make", "undeploy")
+		_, _ = utils.Run(cmd)
+
+		By("uninstalling CRDs")
+		cmd = exec.Command("make", "uninstall")
+		_, _ = utils.Run(cmd)
+	})
+
+	Context("HTTP Connectivity", func() {
+		var hostname string
+
+		BeforeEach(func() {
+			hostname = fmt.Sprintf("test-connectivity-%d.nebari.local", time.Now().Unix())
+		})
+
+		It("should be able to reach the app via HTTP when TLS is disabled", func() {
+			By("creating a NebariApp with TLS disabled")
+			nebariAppYAML := fmt.Sprintf(`
+apiVersion: reconcilers.nebari.dev/v1
+kind: NebariApp
+metadata:
+  name: test-http-connectivity
+  namespace: %s
+spec:
+  hostname: %s
+  service:
+    name: test-app
+    port: 80
+  routing:
+    tls:
+      enabled: false
+`, testNamespace, hostname)
+
+			cmd := exec.Command("kubectl", "apply", "-f", "-")
+			cmd.Stdin = strings.NewReader(nebariAppYAML)
+			_, err := utils.Run(cmd)
+			Expect(err).NotTo(HaveOccurred(), "Failed to create NebariApp")
+
+			By("waiting for NebariApp to be ready")
+			Eventually(func(g Gomega) {
+				cmd := exec.Command("kubectl", "get", "nebariapp", "test-http-connectivity",
+					"-n", testNamespace,
+					"-o", "jsonpath={.status.conditions[?(@.type=='Ready')].status}")
+				output, err := utils.Run(cmd)
+				g.Expect(err).NotTo(HaveOccurred())
+				g.Expect(output).To(Equal("True"))
+			}, 3*time.Minute, 5*time.Second).Should(Succeed())
+
+			By("waiting for HTTPRoute to be accepted")
+			Eventually(func(g Gomega) {
+				cmd := exec.Command("kubectl", "get", "httproute", "test-http-connectivity-route",
+					"-n", testNamespace,
+					"-o", "jsonpath={.status.parents[0].conditions[?(@.type=='Accepted')].status}")
+				output, err := utils.Run(cmd)
+				g.Expect(err).NotTo(HaveOccurred())
+				g.Expect(output).To(Equal("True"))
+			}, 2*time.Minute, 5*time.Second).Should(Succeed())
+
+			By("testing HTTP connectivity via Gateway IP")
+			// Using IP with Host header to avoid DNS requirements
+			Eventually(func(g Gomega) {
+				cmd := exec.Command("curl", "-s", "-o", "/dev/null", "-w", "%{http_code}",
+					"--connect-timeout", "5",
+					"-H", fmt.Sprintf("Host: %s", hostname),
+					fmt.Sprintf("http://%s/", gatewayIP))
+				output, err := utils.Run(cmd)
+				g.Expect(err).NotTo(HaveOccurred())
+				g.Expect(output).To(Equal("200"), "Expected HTTP 200 response")
+			}, 2*time.Minute, 5*time.Second).Should(Succeed())
+
+			By("verifying response body contains expected content")
+			cmd = exec.Command("curl", "-s",
+				"--connect-timeout", "5",
+				"-H", fmt.Sprintf("Host: %s", hostname),
+				fmt.Sprintf("http://%s/", gatewayIP))
+			output, err := utils.Run(cmd)
+			Expect(err).NotTo(HaveOccurred())
+			Expect(output).To(ContainSubstring("Welcome"), "Response should contain app content")
+
+			By("cleaning up NebariApp")
+			cmd = exec.Command("kubectl", "delete", "nebariapp", "test-http-connectivity",
+				"-n", testNamespace, "--ignore-not-found")
+			_, _ = utils.Run(cmd)
+		})
+
+		It("should be able to reach the app via HTTPS when TLS is enabled", func() {
+			By("creating a NebariApp with TLS enabled")
+			nebariAppYAML := fmt.Sprintf(`
+apiVersion: reconcilers.nebari.dev/v1
+kind: NebariApp
+metadata:
+  name: test-https-connectivity
+  namespace: %s
+spec:
+  hostname: %s
+  service:
+    name: test-app
+    port: 80
+  routing:
+    tls:
+      enabled: true
+`, testNamespace, hostname)
+
+			cmd := exec.Command("kubectl", "apply", "-f", "-")
+			cmd.Stdin = strings.NewReader(nebariAppYAML)
+			_, err := utils.Run(cmd)
+			Expect(err).NotTo(HaveOccurred(), "Failed to create NebariApp")
+
+			By("waiting for NebariApp to be ready")
+			Eventually(func(g Gomega) {
+				cmd := exec.Command("kubectl", "get", "nebariapp", "test-https-connectivity",
+					"-n", testNamespace,
+					"-o", "jsonpath={.status.conditions[?(@.type=='Ready')].status}")
+				output, err := utils.Run(cmd)
+				g.Expect(err).NotTo(HaveOccurred())
+				g.Expect(output).To(Equal("True"))
+			}, 3*time.Minute, 5*time.Second).Should(Succeed())
+
+			By("waiting for HTTPRoute to be accepted")
+			Eventually(func(g Gomega) {
+				cmd := exec.Command("kubectl", "get", "httproute", "test-https-connectivity-route",
+					"-n", testNamespace,
+					"-o", "jsonpath={.status.parents[0].conditions[?(@.type=='Accepted')].status}")
+				output, err := utils.Run(cmd)
+				g.Expect(err).NotTo(HaveOccurred())
+				g.Expect(output).To(Equal("True"))
+			}, 2*time.Minute, 5*time.Second).Should(Succeed())
+
+			By("testing HTTPS connectivity via Gateway IP")
+			// Using IP with Host header and SNI, accepting self-signed cert
+			Eventually(func(g Gomega) {
+				cmd := exec.Command("curl", "-s", "-o", "/dev/null", "-w", "%{http_code}",
+					"--connect-timeout", "5",
+					"-k", // Accept self-signed certificate
+					"--resolve", fmt.Sprintf("%s:443:%s", hostname, gatewayIP),
+					fmt.Sprintf("https://%s/", hostname))
+				output, err := utils.Run(cmd)
+				g.Expect(err).NotTo(HaveOccurred())
+				g.Expect(output).To(Equal("200"), "Expected HTTP 200 response")
+			}, 2*time.Minute, 5*time.Second).Should(Succeed())
+
+			By("verifying response body contains expected content")
+			cmd = exec.Command("curl", "-s",
+				"--connect-timeout", "5",
+				"-k",
+				"--resolve", fmt.Sprintf("%s:443:%s", hostname, gatewayIP),
+				fmt.Sprintf("https://%s/", hostname))
+			output, err := utils.Run(cmd)
+			Expect(err).NotTo(HaveOccurred())
+			Expect(output).To(ContainSubstring("Welcome"), "Response should contain app content")
+
+			By("cleaning up NebariApp")
+			cmd = exec.Command("kubectl", "delete", "nebariapp", "test-https-connectivity",
+				"-n", testNamespace, "--ignore-not-found")
+			_, _ = utils.Run(cmd)
+		})
+	})
+})
diff --git a/test/e2e/e2e_suite_test.go b/test/e2e/e2e_suite_test.go
index 720e761..0700726 100644
--- a/test/e2e/e2e_suite_test.go
+++ b/test/e2e/e2e_suite_test.go
@@ -23,7 +23,6 @@ import (
 	"fmt"
 	"os"
 	"os/exec"
-	"strings"
 	"testing"
 
 	. "github.com/onsi/ginkgo/v2"
@@ -34,20 +33,14 @@ import (
 
 var (
 	// Optional Environment Variables:
-	// - CERT_MANAGER_INSTALL_SKIP=true: Skips CertManager installation during test setup.
-	// - KIND_CLUSTER_SKIP=true: Skips Kind cluster creation/deletion during test setup.
-	// - DOCKER_BUILD_SKIP=true: Skips Docker image build during test setup (assumes image is pre-built).
-	// - IMAGE_LOAD_SKIP=true: Skips loading Docker image to Kind (for pre-deployed operators).
-	// These variables are useful if CertManager or Kind cluster are already set up, avoiding
-	// re-installation and conflicts.
-	skipCertManagerInstall    = os.Getenv("CERT_MANAGER_INSTALL_SKIP") == "true"
-	skipKindClusterManagement = os.Getenv("KIND_CLUSTER_SKIP") == "true"
-	skipDockerBuild           = os.Getenv("DOCKER_BUILD_SKIP") == "true"
-	skipImageLoad             = os.Getenv("IMAGE_LOAD_SKIP") == "true"
-
-	// isCertManagerAlreadyInstalled will be set true when CertManager CRDs be found on the cluster
-	isCertManagerAlreadyInstalled = false
-	// isKindClusterCreated will be set true when we create a new Kind cluster
+	// - USE_EXISTING_CLUSTER=true: Use existing cluster instead of creating new Kind cluster
+	// - SETUP_INFRASTRUCTURE=true: Run dev/install-services.sh to setup infrastructure
+	// - SKIP_SETUP=true: Skip all setup (cluster and infrastructure), assume everything exists
+	useExistingCluster  = os.Getenv("USE_EXISTING_CLUSTER") == "true"
+	setupInfrastructure = os.Getenv("SETUP_INFRASTRUCTURE") == "true"
+	skipSetup           = os.Getenv("SKIP_SETUP") == "true"
+
+	// Internal flags
 	isKindClusterCreated = false
 
 	// projectImage is the name of the image which will be build and loaded
@@ -66,72 +59,70 @@ func TestE2E(t *testing.T) {
 }
 
 var _ = BeforeSuite(func() {
-	// Create Kind cluster if not skipped
-	if !skipKindClusterManagement {
-		By("creating kind cluster")
-		err := utils.CreateKindCluster()
+	if skipSetup {
+		_, _ = fmt.Fprintf(GinkgoWriter, "Skipping all setup, using existing cluster and infrastructure\n")
+		return
+	}
+
+	// Set cluster name for Kind utilities
+	clusterName := os.Getenv("CLUSTER_NAME")
+	if clusterName == "" {
+		clusterName = "nic-operator-dev"
+	}
+	os.Setenv("KIND_CLUSTER", clusterName)
+	os.Setenv("CLUSTER_NAME", clusterName)
+
+	// Setup cluster and infrastructure
+	if !useExistingCluster {
+		By("creating kind cluster via dev scripts")
+		cmd := exec.Command("make", "-C", "dev", "cluster-create")
+		_, err := utils.Run(cmd)
 		if err == nil {
 			isKindClusterCreated = true
 		}
 		ExpectWithOffset(1, err).NotTo(HaveOccurred(), "Failed to create Kind cluster")
+	} else {
+		_, _ = fmt.Fprintf(GinkgoWriter, "Using existing cluster\n")
 	}
 
-	// Build Docker image if not skipped
-	if !skipDockerBuild {
-		By("building the manager(Operator) image")
-		cmd := exec.Command("make", "docker-build", fmt.Sprintf("IMG=%s", projectImage))
+	// Setup infrastructure (Envoy Gateway, cert-manager, Gateway, etc.)
+	if setupInfrastructure {
+		By("installing foundational services via dev scripts")
+		cmd := exec.Command("make", "-C", "dev", "services-install")
 		_, err := utils.Run(cmd)
-		ExpectWithOffset(1, err).NotTo(HaveOccurred(), "Failed to build the manager(Operator) image")
+		ExpectWithOffset(1, err).NotTo(HaveOccurred(), "Failed to install foundational services")
+	} else {
+		_, _ = fmt.Fprintf(GinkgoWriter, "Skipping infrastructure setup, assuming services are already installed\n")
 	}
 
-	// Load image to Kind if not skipped
-	if !skipImageLoad {
-		// TODO(user): If you want to change the e2e test vendor from Kind, ensure the image is
-		// built and available before running the tests. Also, remove the following block.
-		By("loading the manager(Operator) image on Kind")
-		err := utils.LoadImageToKindClusterWithName(projectImage)
-
-		// If loading fails due to unhealthy cluster, try recreating it once
-		if err != nil && !skipKindClusterManagement && strings.Contains(err.Error(), "has no nodes") {
-			_, _ = fmt.Fprintf(GinkgoWriter, "Cluster became unhealthy, recreating...\n")
-			_ = utils.DeleteKindCluster()
-			err = utils.CreateKindCluster()
-			ExpectWithOffset(1, err).NotTo(HaveOccurred(), "Failed to recreate Kind cluster")
-
-			// Try loading image again
-			err = utils.LoadImageToKindClusterWithName(projectImage)
-		}
-
-		ExpectWithOffset(1, err).NotTo(HaveOccurred(), "Failed to load the manager(Operator) image into Kind")
-	}
+	// Build and load operator image
+	By("building the manager(Operator) image")
+	cmd := exec.Command("make", "docker-build", fmt.Sprintf("IMG=%s", projectImage))
+	_, err := utils.Run(cmd)
+	ExpectWithOffset(1, err).NotTo(HaveOccurred(), "Failed to build the manager(Operator) image")
 
-	// The tests-e2e are intended to run on a temporary cluster that is created and destroyed for testing.
-	// To prevent errors when tests run in environments with CertManager already installed,
-	// we check for its presence before execution.
-	// Setup CertManager before the suite if not skipped and if not already installed
-	if !skipCertManagerInstall {
-		By("checking if cert manager is installed already")
-		isCertManagerAlreadyInstalled = utils.IsCertManagerCRDsInstalled()
-		if !isCertManagerAlreadyInstalled {
-			_, _ = fmt.Fprintf(GinkgoWriter, "Installing CertManager...\n")
-			Expect(utils.InstallCertManager()).To(Succeed(), "Failed to install CertManager")
-		} else {
-			_, _ = fmt.Fprintf(GinkgoWriter, "WARNING: CertManager is already installed. Skipping installation...\n")
-		}
-	}
+	By("loading the manager(Operator) image on Kind")
+	err = utils.LoadImageToKindClusterWithName(projectImage)
+	ExpectWithOffset(1, err).NotTo(HaveOccurred(), "Failed to load the manager(Operator) image into Kind")
 })
 
 var _ = AfterSuite(func() {
-	// Teardown CertManager after the suite if not skipped and if it was not already installed
-	if !skipCertManagerInstall && !isCertManagerAlreadyInstalled {
-		_, _ = fmt.Fprintf(GinkgoWriter, "Uninstalling CertManager...\n")
-		utils.UninstallCertManager()
+	if skipSetup {
+		return
+	}
+
+	// Teardown via dev scripts if we set things up
+	if setupInfrastructure {
+		_, _ = fmt.Fprintf(GinkgoWriter, "Uninstalling foundational services...\n")
+		cmd := exec.Command("make", "-C", "dev", "services-uninstall")
+		_, _ = utils.Run(cmd)
 	}
 
 	// Delete Kind cluster if we created it
-	if !skipKindClusterManagement && isKindClusterCreated {
+	if isKindClusterCreated {
 		By("deleting kind cluster")
-		if err := utils.DeleteKindCluster(); err != nil {
+		cmd := exec.Command("make", "-C", "dev", "cluster-delete")
+		if _, err := utils.Run(cmd); err != nil {
 			warnError(err)
 		}
 	}
diff --git a/test/e2e/e2e_test.go b/test/e2e/e2e_test.go
index f799d13..5c21547 100644
--- a/test/e2e/e2e_test.go
+++ b/test/e2e/e2e_test.go
@@ -19,384 +19,4 @@ limitations under the License.
 
 package e2e
 
-import (
-	"encoding/json"
-	"fmt"
-	"os"
-	"os/exec"
-	"path/filepath"
-	"strings"
-	"time"
-
-	. "github.com/onsi/ginkgo/v2"
-	. "github.com/onsi/gomega"
-
-	"github.com/nebari-dev/nebari-operator/test/utils"
-)
-
-// namespace where the project is deployed in
-const namespace = "nebari-operator-system"
-
-// serviceAccountName created for the project
-const serviceAccountName = "nebari-operator-controller-manager"
-
-// metricsServiceName is the name of the metrics service of the project
-const metricsServiceName = "nebari-operator-controller-manager-metrics-service"
-
-// metricsRoleBindingName is the name of the RBAC that will be created to allow get the metrics data
-const metricsRoleBindingName = "nebari-operator-metrics-binding"
-
-var _ = Describe("Manager", Ordered, func() {
-	var controllerPodName string
-
-	// Before running the tests, set up the environment by creating the namespace,
-	// enforce the restricted security policy to the namespace, installing CRDs,
-	// and deploying the controller.
-	BeforeAll(func() {
-		By("creating manager namespace")
-		cmd := exec.Command("kubectl", "create", "ns", namespace)
-		_, err := utils.Run(cmd)
-		Expect(err).NotTo(HaveOccurred(), "Failed to create namespace")
-
-		By("labeling the namespace to enforce the restricted security policy")
-		cmd = exec.Command("kubectl", "label", "--overwrite", "ns", namespace,
-			"pod-security.kubernetes.io/enforce=restricted")
-		_, err = utils.Run(cmd)
-		Expect(err).NotTo(HaveOccurred(), "Failed to label namespace with restricted policy")
-
-		By("installing CRDs")
-		cmd = exec.Command("make", "install")
-		_, err = utils.Run(cmd)
-		Expect(err).NotTo(HaveOccurred(), "Failed to install CRDs")
-
-		By("deploying the controller-manager")
-		cmd = exec.Command("make", "deploy", fmt.Sprintf("IMG=%s", projectImage))
-		_, err = utils.Run(cmd)
-		Expect(err).NotTo(HaveOccurred(), "Failed to deploy the controller-manager")
-	})
-
-	// After all tests have been executed, clean up by undeploying the controller, uninstalling CRDs,
-	// and deleting the namespace.
-	AfterAll(func() {
-		By("cleaning up the curl pod for metrics")
-		cmd := exec.Command("kubectl", "delete", "pod", "curl-metrics", "-n", namespace)
-		_, _ = utils.Run(cmd)
-
-		By("undeploying the controller-manager")
-		cmd = exec.Command("make", "undeploy")
-		_, _ = utils.Run(cmd)
-
-		By("uninstalling CRDs")
-		cmd = exec.Command("make", "uninstall")
-		_, _ = utils.Run(cmd)
-
-		By("removing manager namespace")
-		cmd = exec.Command("kubectl", "delete", "ns", namespace)
-		_, _ = utils.Run(cmd)
-	})
-
-	// After each test, check for failures and collect logs, events,
-	// and pod descriptions for debugging.
-	AfterEach(func() {
-		specReport := CurrentSpecReport()
-		if specReport.Failed() {
-			By("Fetching controller manager pod logs")
-			cmd := exec.Command("kubectl", "logs", controllerPodName, "-n", namespace)
-			controllerLogs, err := utils.Run(cmd)
-			if err == nil {
-				_, _ = fmt.Fprintf(GinkgoWriter, "Controller logs:\n %s", controllerLogs)
-			} else {
-				_, _ = fmt.Fprintf(GinkgoWriter, "Failed to get Controller logs: %s", err)
-			}
-
-			By("Fetching Kubernetes events")
-			cmd = exec.Command("kubectl", "get", "events", "-n", namespace, "--sort-by=.lastTimestamp")
-			eventsOutput, err := utils.Run(cmd)
-			if err == nil {
-				_, _ = fmt.Fprintf(GinkgoWriter, "Kubernetes events:\n%s", eventsOutput)
-			} else {
-				_, _ = fmt.Fprintf(GinkgoWriter, "Failed to get Kubernetes events: %s", err)
-			}
-
-			By("Fetching curl-metrics logs")
-			cmd = exec.Command("kubectl", "logs", "curl-metrics", "-n", namespace)
-			metricsOutput, err := utils.Run(cmd)
-			if err == nil {
-				_, _ = fmt.Fprintf(GinkgoWriter, "Metrics logs:\n %s", metricsOutput)
-			} else {
-				_, _ = fmt.Fprintf(GinkgoWriter, "Failed to get curl-metrics logs: %s", err)
-			}
-
-			By("Fetching controller manager pod description")
-			cmd = exec.Command("kubectl", "describe", "pod", controllerPodName, "-n", namespace)
-			podDescription, err := utils.Run(cmd)
-			if err == nil {
-				fmt.Println("Pod description:\n", podDescription)
-			} else {
-				fmt.Println("Failed to describe controller pod")
-			}
-		}
-	})
-
-	SetDefaultEventuallyTimeout(2 * time.Minute)
-	SetDefaultEventuallyPollingInterval(time.Second)
-
-	Context("Manager", func() {
-		It("should run successfully", func() {
-			By("validating that the controller-manager pod is running as expected")
-			verifyControllerUp := func(g Gomega) {
-				// Get the name of the controller-manager pod
-				cmd := exec.Command("kubectl", "get",
-					"pods", "-l", "control-plane=controller-manager",
-					"-o", "go-template={{ range .items }}"+
-						"{{ if not .metadata.deletionTimestamp }}"+
-						"{{ .metadata.name }}"+
-						"{{ \"\\n\" }}{{ end }}{{ end }}",
-					"-n", namespace,
-				)
-
-				podOutput, err := utils.Run(cmd)
-				g.Expect(err).NotTo(HaveOccurred(), "Failed to retrieve controller-manager pod information")
-				podNames := utils.GetNonEmptyLines(podOutput)
-				g.Expect(podNames).To(HaveLen(1), "expected 1 controller pod running")
-				controllerPodName = podNames[0]
-				g.Expect(controllerPodName).To(ContainSubstring("controller-manager"))
-
-				// Validate the pod's status
-				cmd = exec.Command("kubectl", "get",
-					"pods", controllerPodName, "-o", "jsonpath={.status.phase}",
-					"-n", namespace,
-				)
-				output, err := utils.Run(cmd)
-				g.Expect(err).NotTo(HaveOccurred())
-				g.Expect(output).To(Equal("Running"), "Incorrect controller-manager pod status")
-			}
-			Eventually(verifyControllerUp).Should(Succeed())
-		})
-
-		It("should ensure the metrics endpoint is serving metrics", func() {
-			By("creating a ClusterRoleBinding for the service account to allow access to metrics")
-			cmd := exec.Command("kubectl", "create", "clusterrolebinding", metricsRoleBindingName,
-				"--clusterrole=nebari-operator-metrics-reader",
-				fmt.Sprintf("--serviceaccount=%s:%s", namespace, serviceAccountName),
-			)
-			_, err := utils.Run(cmd)
-			Expect(err).NotTo(HaveOccurred(), "Failed to create ClusterRoleBinding")
-
-			By("validating that the metrics service is available")
-			cmd = exec.Command("kubectl", "get", "service", metricsServiceName, "-n", namespace)
-			_, err = utils.Run(cmd)
-			Expect(err).NotTo(HaveOccurred(), "Metrics service should exist")
-
-			By("getting the service account token")
-			token, err := serviceAccountToken()
-			Expect(err).NotTo(HaveOccurred())
-			Expect(token).NotTo(BeEmpty())
-
-			By("ensuring the controller pod is ready")
-			verifyControllerPodReady := func(g Gomega) {
-				cmd := exec.Command("kubectl", "get", "pod", controllerPodName, "-n", namespace,
-					"-o", "jsonpath={.status.conditions[?(@.type=='Ready')].status}")
-				output, err := utils.Run(cmd)
-				g.Expect(err).NotTo(HaveOccurred())
-				g.Expect(output).To(Equal("True"), "Controller pod not ready")
-			}
-			Eventually(verifyControllerPodReady, 3*time.Minute, time.Second).Should(Succeed())
-
-			By("verifying that the controller manager is serving the metrics server")
-			verifyMetricsServerStarted := func(g Gomega) {
-				cmd := exec.Command("kubectl", "logs", controllerPodName, "-n", namespace)
-				output, err := utils.Run(cmd)
-				g.Expect(err).NotTo(HaveOccurred())
-				g.Expect(output).To(ContainSubstring("Serving metrics server"),
-					"Metrics server not yet started")
-			}
-			Eventually(verifyMetricsServerStarted, 3*time.Minute, time.Second).Should(Succeed())
-
-			// +kubebuilder:scaffold:e2e-metrics-webhooks-readiness
-
-			By("creating the curl-metrics pod to access the metrics endpoint")
-			cmd = exec.Command("kubectl", "run", "curl-metrics", "--restart=Never",
-				"--namespace", namespace,
-				"--image=curlimages/curl:latest",
-				"--overrides",
-				fmt.Sprintf(`{
-					"spec": {
-						"containers": [{
-							"name": "curl",
-							"image": "curlimages/curl:latest",
-							"command": ["/bin/sh", "-c"],
-							"args": ["curl -v -k -H 'Authorization: Bearer %s' https://%s.%s.svc.cluster.local:8443/metrics"],
-							"securityContext": {
-								"readOnlyRootFilesystem": true,
-								"allowPrivilegeEscalation": false,
-								"capabilities": {
-									"drop": ["ALL"]
-								},
-								"runAsNonRoot": true,
-								"runAsUser": 1000,
-								"seccompProfile": {
-									"type": "RuntimeDefault"
-								}
-							}
-						}],
-						"serviceAccountName": "%s"
-					}
-				}`, token, metricsServiceName, namespace, serviceAccountName))
-			_, err = utils.Run(cmd)
-			Expect(err).NotTo(HaveOccurred(), "Failed to create curl-metrics pod")
-
-			By("waiting for the curl-metrics pod to complete.")
-			verifyCurlUp := func(g Gomega) {
-				cmd := exec.Command("kubectl", "get", "pods", "curl-metrics",
-					"-o", "jsonpath={.status.phase}",
-					"-n", namespace)
-				output, err := utils.Run(cmd)
-				g.Expect(err).NotTo(HaveOccurred())
-				g.Expect(output).To(Equal("Succeeded"), "curl pod in wrong status")
-			}
-			Eventually(verifyCurlUp, 5*time.Minute).Should(Succeed())
-
-			By("getting the metrics by checking curl-metrics logs")
-			verifyMetricsAvailable := func(g Gomega) {
-				metricsOutput, err := getMetricsOutput()
-				g.Expect(err).NotTo(HaveOccurred(), "Failed to retrieve logs from curl pod")
-				g.Expect(metricsOutput).NotTo(BeEmpty())
-				g.Expect(metricsOutput).To(ContainSubstring("< HTTP/1.1 200 OK"))
-			}
-			Eventually(verifyMetricsAvailable, 2*time.Minute).Should(Succeed())
-		})
-		// +kubebuilder:scaffold:e2e-webhooks-checks
-	})
-
-	Context("NebariApp Reconciliation", func() {
-		var testNamespace string
-
-		BeforeAll(func() {
-			testNamespace = "e2e-test-app"
-
-			By("cleaning up any existing test resources")
-			cmd := exec.Command("kubectl", "delete", "namespace", testNamespace, "--ignore-not-found", "--timeout=60s")
-			_, _ = utils.Run(cmd)
-			cmd = exec.Command("kubectl", "delete", "gateway", "test-gateway", "-n", "default", "--ignore-not-found")
-			_, _ = utils.Run(cmd)
-
-			By("creating test namespace")
-			cmd = exec.Command("kubectl", "create", "namespace", testNamespace)
-			_, err := utils.Run(cmd)
-			By("labeling namespace for Operator management")
-			cmd = exec.Command("kubectl", "label", "namespace", testNamespace, "nebari.dev/managed=true")
-			_, err = utils.Run(cmd)
-			Expect(err).NotTo(HaveOccurred(), "Failed to label namespace")
-
-			By("creating a test application deployment")
-			appYAML, err := utils.LoadTestDataFile("test-app.yaml", map[string]string{
-				"NAMESPACE_PLACEHOLDER": testNamespace,
-			})
-			Expect(err).NotTo(HaveOccurred(), "Failed to load test-app.yaml")
-
-			cmd = exec.Command("kubectl", "apply", "-f", "-")
-			cmd.Stdin = strings.NewReader(appYAML)
-			_, err = utils.Run(cmd)
-			Expect(err).NotTo(HaveOccurred(), "Failed to create test application")
-
-			By("waiting for test application to be ready")
-			Eventually(func(g Gomega) {
-				cmd := exec.Command("kubectl", "get", "deployment", "test-app", "-n", testNamespace,
-					"-o", "jsonpath={.status.availableReplicas}")
-				output, err := utils.Run(cmd)
-				g.Expect(err).NotTo(HaveOccurred())
-				g.Expect(output).To(Equal("1"))
-			}, 2*time.Minute, time.Second).Should(Succeed())
-		})
-
-		AfterAll(func() {
-			By("cleaning up test resources")
-			cmd := exec.Command("kubectl", "delete", "namespace", testNamespace, "--ignore-not-found")
-			_, _ = utils.Run(cmd)
-
-			cmd = exec.Command("kubectl", "delete", "gateway", "test-gateway", "-n", "default", "--ignore-not-found")
-			_, _ = utils.Run(cmd)
-		})
-
-		It("should reconcile a NebariApp resource successfully", func() {
-			By("creating a NebariApp resource")
-			nebariAppYAML, err := utils.LoadTestDataFile("nebariapp.yaml", map[string]string{
-				"NAMESPACE_PLACEHOLDER": testNamespace,
-				"NAME_PLACEHOLDER":      "test-nebariapp",
-			})
-			Expect(err).NotTo(HaveOccurred(), "Failed to load nebariapp.yaml")
-
-			cmd := exec.Command("kubectl", "apply", "-f", "-")
-			cmd.Stdin = strings.NewReader(nebariAppYAML)
-			_, err = utils.Run(cmd)
-			Expect(err).NotTo(HaveOccurred(), "Failed to create NebariApp resource")
-
-			By("verifying that the NebariApp resource is reconciled")
-			Eventually(func(g Gomega) {
-				cmd := exec.Command("kubectl", "get", "nebariapp", "test-nebariapp",
-					"-n", testNamespace,
-					"-o", "jsonpath={.status.conditions[?(@.type=='Ready')].status}")
-				output, err := utils.Run(cmd)
-				g.Expect(err).NotTo(HaveOccurred())
-				g.Expect(output).To(Equal("True"), "NebariApp not ready")
-			}, 3*time.Minute, 5*time.Second).Should(Succeed())
-		})
-	})
-})
-
-// serviceAccountToken returns a token for the specified service account in the given namespace.
-// It uses the Kubernetes TokenRequest API to generate a token by directly sending a request
-// and parsing the resulting token from the API response.
-func serviceAccountToken() (string, error) {
-	const tokenRequestRawString = `{
-		"apiVersion": "authentication.k8s.io/v1",
-		"kind": "TokenRequest"
-	}`
-
-	// Temporary file to store the token request
-	secretName := fmt.Sprintf("%s-token-request", serviceAccountName)
-	tokenRequestFile := filepath.Join("/tmp", secretName)
-	err := os.WriteFile(tokenRequestFile, []byte(tokenRequestRawString), os.FileMode(0o644))
-	if err != nil {
-		return "", err
-	}
-
-	var out string
-	verifyTokenCreation := func(g Gomega) {
-		// Execute kubectl command to create the token
-		cmd := exec.Command("kubectl", "create", "--raw", fmt.Sprintf(
-			"/api/v1/namespaces/%s/serviceaccounts/%s/token",
-			namespace,
-			serviceAccountName,
-		), "-f", tokenRequestFile)
-
-		output, err := cmd.CombinedOutput()
-		g.Expect(err).NotTo(HaveOccurred())
-
-		// Parse the JSON output to extract the token
-		var token tokenRequest
-		err = json.Unmarshal(output, &token)
-		g.Expect(err).NotTo(HaveOccurred())
-
-		out = token.Status.Token
-	}
-	Eventually(verifyTokenCreation).Should(Succeed())
-
-	return out, err
-}
-
-// getMetricsOutput retrieves and returns the logs from the curl pod used to access the metrics endpoint.
-func getMetricsOutput() (string, error) {
-	By("getting the curl-metrics logs")
-	cmd := exec.Command("kubectl", "logs", "curl-metrics", "-n", namespace)
-	return utils.Run(cmd)
-}
-
-// tokenRequest is a simplified representation of the Kubernetes TokenRequest API response,
-// containing only the token field that we need to extract.
-type tokenRequest struct {
-	Status struct {
-		Token string `json:"token"`
-	} `json:"status"`
-}
+// Constants moved to e2e_utils.go for better sharing across test files
diff --git a/test/e2e/e2e_utils.go b/test/e2e/e2e_utils.go
new file mode 100644
index 0000000..ced9dea
--- /dev/null
+++ b/test/e2e/e2e_utils.go
@@ -0,0 +1,103 @@
+//go:build e2e
+// +build e2e
+
+/*
+Copyright 2026, OpenTeams.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package e2e
+
+import (
+	"encoding/json"
+	"fmt"
+	"os"
+	"os/exec"
+	"path/filepath"
+
+	. "github.com/onsi/ginkgo/v2"
+	. "github.com/onsi/gomega"
+
+	"github.com/nebari-dev/nebari-operator/test/utils"
+)
+
+// Constants used across e2e tests
+const (
+	// namespace where the project is deployed in
+	namespace = "nebari-operator-system"
+	// serviceAccountName created for the project
+	serviceAccountName = "nebari-operator-controller-manager"
+	// metricsServiceName is the name of the metrics service of the project
+	metricsServiceName = "nebari-operator-controller-manager-metrics-service"
+	// metricsRoleBindingName is the name of the RBAC that will be created to allow get the metrics data
+	metricsRoleBindingName = "nebari-operator-metrics-binding"
+	// metricsRoleName is the name of the ClusterRole for metrics access
+	metricsRoleName = "nebari-operator-metrics-reader"
+)
+
+// serviceAccountToken returns a token for the specified service account in the given namespace.
+// It uses the Kubernetes TokenRequest API to generate a token by directly sending a request
+// and parsing the resulting token from the API response.
+func serviceAccountToken() (string, error) {
+	const tokenRequestRawString = `{
+		"apiVersion": "authentication.k8s.io/v1",
+		"kind": "TokenRequest"
+	}`
+
+	// Temporary file to store the token request
+	secretName := fmt.Sprintf("%s-token-request", serviceAccountName)
+	tokenRequestFile := filepath.Join("/tmp", secretName)
+	err := os.WriteFile(tokenRequestFile, []byte(tokenRequestRawString), os.FileMode(0o644))
+	if err != nil {
+		return "", err
+	}
+
+	var out string
+	verifyTokenCreation := func(g Gomega) {
+		// Execute kubectl command to create the token
+		cmd := exec.Command("kubectl", "create", "--raw", fmt.Sprintf(
+			"/api/v1/namespaces/%s/serviceaccounts/%s/token",
+			namespace,
+			serviceAccountName,
+		), "-f", tokenRequestFile)
+
+		output, err := cmd.CombinedOutput()
+		g.Expect(err).NotTo(HaveOccurred())
+
+		// Parse the JSON output to extract the token
+		var token tokenRequest
+		err = json.Unmarshal(output, &token)
+		g.Expect(err).NotTo(HaveOccurred())
+
+		out = token.Status.Token
+	}
+	Eventually(verifyTokenCreation).Should(Succeed())
+
+	return out, err
+}
+
+// getMetricsOutput retrieves and returns the logs from the curl pod used to access the metrics endpoint.
+func getMetricsOutput() (string, error) {
+	By("getting the curl-metrics logs")
+	cmd := exec.Command("kubectl", "logs", "curl-metrics", "-n", namespace)
+	return utils.Run(cmd)
+}
+
+// tokenRequest is a simplified representation of the Kubernetes TokenRequest API response,
+// containing only the token field that we need to extract.
+type tokenRequest struct {
+	Status struct {
+		Token string `json:"token"`
+	} `json:"status"`
+}
diff --git a/test/e2e/gateway_test.go b/test/e2e/gateway_test.go
new file mode 100644
index 0000000..b209d6c
--- /dev/null
+++ b/test/e2e/gateway_test.go
@@ -0,0 +1,156 @@
+//go:build e2e
+// +build e2e
+
+/*
+Copyright 2026, OpenTeams.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package e2e
+
+import (
+	"encoding/json"
+	"os/exec"
+
+	. "github.com/onsi/ginkgo/v2"
+	. "github.com/onsi/gomega"
+
+	"github.com/nebari-dev/nebari-operator/test/utils"
+)
+
+var _ = Describe("Gateway and cert-manager Integration", Ordered, func() {
+	BeforeAll(func() {
+		// Check if Gateway API CRDs are installed
+		cmd := exec.Command("kubectl", "get", "crd", "gateways.gateway.networking.k8s.io")
+		_, err := utils.Run(cmd)
+		if err != nil {
+			Skip("Gateway API CRDs not installed - skipping Gateway integration tests")
+		}
+	})
+
+	It("should have Gateway configured", func() {
+		By("checking Gateway exists")
+		cmd := exec.Command("kubectl", "get", "gateway", "nebari-gateway", "-n", "envoy-gateway-system",
+			"-o", "jsonpath={.metadata.name}")
+		output, err := utils.Run(cmd)
+		Expect(err).NotTo(HaveOccurred(), "Gateway nebari-gateway should exist")
+		Expect(output).To(Equal("nebari-gateway"))
+
+		By("verifying Gateway has HTTP and HTTPS listeners")
+		cmd = exec.Command("kubectl", "get", "gateway", "nebari-gateway", "-n", "envoy-gateway-system",
+			"-o", "jsonpath={.spec.listeners[*].name}")
+		output, err = utils.Run(cmd)
+		Expect(err).NotTo(HaveOccurred())
+		Expect(output).To(ContainSubstring("http"))
+		Expect(output).To(ContainSubstring("https"))
+
+		By("verifying Gateway uses envoy-gateway GatewayClass")
+		cmd = exec.Command("kubectl", "get", "gateway", "nebari-gateway", "-n", "envoy-gateway-system",
+			"-o", "jsonpath={.spec.gatewayClassName}")
+		output, err = utils.Run(cmd)
+		Expect(err).NotTo(HaveOccurred())
+		Expect(output).To(Equal("envoy-gateway"))
+
+		By("verifying HTTPS listener references TLS certificate")
+		cmd = exec.Command("kubectl", "get", "gateway", "nebari-gateway", "-n", "envoy-gateway-system",
+			"-o", "json")
+		output, err = utils.Run(cmd)
+		Expect(err).NotTo(HaveOccurred())
+
+		var gateway map[string]interface{}
+		err = json.Unmarshal([]byte(output), &gateway)
+		Expect(err).NotTo(HaveOccurred())
+
+		spec := gateway["spec"].(map[string]interface{})
+		listeners := spec["listeners"].([]interface{})
+
+		var httpsListener map[string]interface{}
+		for _, l := range listeners {
+			listener := l.(map[string]interface{})
+			if listener["name"].(string) == "https" {
+				httpsListener = listener
+				break
+			}
+		}
+
+		Expect(httpsListener).NotTo(BeNil(), "HTTPS listener should exist")
+		tls := httpsListener["tls"].(map[string]interface{})
+		certRefs := tls["certificateRefs"].([]interface{})
+		Expect(certRefs).To(HaveLen(1))
+		certRef := certRefs[0].(map[string]interface{})
+		Expect(certRef["name"]).To(Equal("nebari-gateway-tls"))
+	})
+
+	It("should have GatewayClass configured", func() {
+		By("checking GatewayClass exists")
+		cmd := exec.Command("kubectl", "get", "gatewayclass", "envoy-gateway",
+			"-o", "jsonpath={.metadata.name}")
+		output, err := utils.Run(cmd)
+		Expect(err).NotTo(HaveOccurred(), "GatewayClass envoy-gateway should exist")
+		Expect(output).To(Equal("envoy-gateway"))
+
+		By("verifying GatewayClass controller")
+		cmd = exec.Command("kubectl", "get", "gatewayclass", "envoy-gateway",
+			"-o", "jsonpath={.spec.controllerName}")
+		output, err = utils.Run(cmd)
+		Expect(err).NotTo(HaveOccurred())
+		Expect(output).To(Equal("gateway.envoyproxy.io/gatewayclass-controller"))
+	})
+
+	It("should have wildcard TLS certificate", func() {
+		By("checking TLS secret exists")
+		cmd := exec.Command("kubectl", "get", "secret", "nebari-gateway-tls", "-n", "envoy-gateway-system",
+			"-o", "jsonpath={.metadata.name}")
+		output, err := utils.Run(cmd)
+		Expect(err).NotTo(HaveOccurred(), "TLS secret nebari-gateway-tls should exist")
+		Expect(output).To(Equal("nebari-gateway-tls"))
+
+		By("verifying secret is of type TLS")
+		cmd = exec.Command("kubectl", "get", "secret", "nebari-gateway-tls", "-n", "envoy-gateway-system",
+			"-o", "jsonpath={.type}")
+		output, err = utils.Run(cmd)
+		Expect(err).NotTo(HaveOccurred())
+		Expect(output).To(Equal("kubernetes.io/tls"))
+
+		By("verifying secret contains certificate data")
+		cmd = exec.Command("kubectl", "get", "secret", "nebari-gateway-tls", "-n", "envoy-gateway-system",
+			"-o", "jsonpath={.data['tls\\.crt']}")
+		output, err = utils.Run(cmd)
+		Expect(err).NotTo(HaveOccurred())
+		Expect(output).NotTo(BeEmpty(), "TLS certificate data should not be empty")
+	})
+
+	It("should have cert-manager Certificate resource", func() {
+		By("checking if Certificate resource exists")
+		cmd := exec.Command("kubectl", "get", "certificate", "nebari-gateway-cert", "-n", "envoy-gateway-system",
+			"-o", "jsonpath={.metadata.name}")
+		output, err := utils.Run(cmd)
+		Expect(err).NotTo(HaveOccurred(), "Certificate nebari-gateway-cert should exist")
+		Expect(output).To(Equal("nebari-gateway-cert"))
+
+		By("verifying Certificate references the TLS secret")
+		cmd = exec.Command("kubectl", "get", "certificate", "nebari-gateway-cert", "-n", "envoy-gateway-system",
+			"-o", "jsonpath={.spec.secretName}")
+		output, err = utils.Run(cmd)
+		Expect(err).NotTo(HaveOccurred())
+		Expect(output).To(Equal("nebari-gateway-tls"))
+
+		By("verifying Certificate status is Ready")
+		cmd = exec.Command("kubectl", "get", "certificate", "nebari-gateway-cert", "-n", "envoy-gateway-system",
+			"-o", "jsonpath={.status.conditions[?(@.type=='Ready')].status}")
+		output, err = utils.Run(cmd)
+		Expect(err).NotTo(HaveOccurred())
+		Expect(output).To(Equal("True"), "Certificate should be Ready")
+	})
+})
diff --git a/test/e2e/manager_test.go b/test/e2e/manager_test.go
new file mode 100644
index 0000000..7bd03ec
--- /dev/null
+++ b/test/e2e/manager_test.go
@@ -0,0 +1,257 @@
+//go:build e2e
+// +build e2e
+
+/*
+Copyright 2026, OpenTeams.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package e2e
+
+import (
+	"fmt"
+	"os/exec"
+	"time"
+
+	. "github.com/onsi/ginkgo/v2"
+	. "github.com/onsi/gomega"
+
+	"github.com/nebari-dev/nebari-operator/test/utils"
+)
+
+var _ = Describe("Manager", Ordered, func() {
+	var controllerPodName string
+
+	// Before running the tests, set up the environment by creating the namespace,
+	// enforce the restricted security policy to the namespace, installing CRDs,
+	// and deploying the controller.
+	BeforeAll(func() {
+		By("creating manager namespace")
+		cmd := exec.Command("kubectl", "create", "ns", namespace)
+		_, err := utils.Run(cmd)
+		Expect(err).NotTo(HaveOccurred(), "Failed to create namespace")
+
+		By("labeling the namespace to enforce the restricted security policy")
+		cmd = exec.Command("kubectl", "label", "--overwrite", "ns", namespace,
+			"pod-security.kubernetes.io/enforce=restricted")
+		_, err = utils.Run(cmd)
+		Expect(err).NotTo(HaveOccurred(), "Failed to label namespace with restricted policy")
+
+		By("installing CRDs")
+		cmd = exec.Command("make", "install")
+		_, err = utils.Run(cmd)
+		Expect(err).NotTo(HaveOccurred(), "Failed to install CRDs")
+
+		By("deploying the controller-manager")
+		cmd = exec.Command("make", "deploy", fmt.Sprintf("IMG=%s", projectImage))
+		_, err = utils.Run(cmd)
+		Expect(err).NotTo(HaveOccurred(), "Failed to deploy the controller-manager")
+	})
+
+	// After all tests have been executed, clean up by undeploying the controller, uninstalling CRDs,
+	// and deleting the namespace.
+	AfterAll(func() {
+		By("cleaning up the curl pod for metrics")
+		cmd := exec.Command("kubectl", "delete", "pod", "curl-metrics", "-n", namespace)
+		_, _ = utils.Run(cmd)
+
+		By("undeploying the controller-manager")
+		cmd = exec.Command("make", "undeploy")
+		_, _ = utils.Run(cmd)
+
+		By("uninstalling CRDs")
+		cmd = exec.Command("make", "uninstall")
+		_, _ = utils.Run(cmd)
+
+		By("removing manager namespace")
+		cmd = exec.Command("kubectl", "delete", "ns", namespace)
+		_, _ = utils.Run(cmd)
+	})
+
+	// After each test, check for failures and collect logs, events,
+	// and pod descriptions for debugging.
+	AfterEach(func() {
+		specReport := CurrentSpecReport()
+		if specReport.Failed() {
+			By("Fetching controller manager pod logs")
+			cmd := exec.Command("kubectl", "logs", controllerPodName, "-n", namespace)
+			controllerLogs, err := utils.Run(cmd)
+			if err == nil {
+				_, _ = fmt.Fprintf(GinkgoWriter, "Controller logs:\n %s", controllerLogs)
+			} else {
+				_, _ = fmt.Fprintf(GinkgoWriter, "Failed to get Controller logs: %s", err)
+			}
+
+			By("Fetching Kubernetes events")
+			cmd = exec.Command("kubectl", "get", "events", "-n", namespace, "--sort-by=.lastTimestamp")
+			eventsOutput, err := utils.Run(cmd)
+			if err == nil {
+				_, _ = fmt.Fprintf(GinkgoWriter, "Kubernetes events:\n%s", eventsOutput)
+			} else {
+				_, _ = fmt.Fprintf(GinkgoWriter, "Failed to get Kubernetes events: %s", err)
+			}
+
+			By("Fetching curl-metrics logs")
+			cmd = exec.Command("kubectl", "logs", "curl-metrics", "-n", namespace)
+			metricsOutput, err := utils.Run(cmd)
+			if err == nil {
+				_, _ = fmt.Fprintf(GinkgoWriter, "Metrics logs:\n %s", metricsOutput)
+			} else {
+				_, _ = fmt.Fprintf(GinkgoWriter, "Failed to get curl-metrics logs: %s", err)
+			}
+
+			By("Fetching controller manager pod description")
+			cmd = exec.Command("kubectl", "describe", "pod", controllerPodName, "-n", namespace)
+			podDescription, err := utils.Run(cmd)
+			if err == nil {
+				fmt.Println("Pod description:\n", podDescription)
+			} else {
+				fmt.Println("Failed to describe controller pod")
+			}
+		}
+	})
+
+	SetDefaultEventuallyTimeout(2 * time.Minute)
+	SetDefaultEventuallyPollingInterval(time.Second)
+
+	Context("Manager", func() {
+		It("should run successfully", func() {
+			By("validating that the controller-manager pod is running as expected")
+			verifyControllerUp := func(g Gomega) {
+				// Get the name of the controller-manager pod
+				cmd := exec.Command("kubectl", "get",
+					"pods", "-l", "control-plane=controller-manager",
+					"-o", "go-template={{ range .items }}"+
+						"{{ if not .metadata.deletionTimestamp }}"+
+						"{{ .metadata.name }}"+
+						"{{ \"\\n\" }}{{ end }}{{ end }}",
+					"-n", namespace,
+				)
+
+				podOutput, err := utils.Run(cmd)
+				g.Expect(err).NotTo(HaveOccurred(), "Failed to retrieve controller-manager pod information")
+				podNames := utils.GetNonEmptyLines(podOutput)
+				g.Expect(podNames).To(HaveLen(1), "expected 1 controller pod running")
+				controllerPodName = podNames[0]
+				g.Expect(controllerPodName).To(ContainSubstring("controller-manager"))
+
+				// Validate the pod's status
+				cmd = exec.Command("kubectl", "get",
+					"pods", controllerPodName, "-o", "jsonpath={.status.phase}",
+					"-n", namespace,
+				)
+				output, err := utils.Run(cmd)
+				g.Expect(err).NotTo(HaveOccurred())
+				g.Expect(output).To(Equal("Running"), "Incorrect controller-manager pod status")
+			}
+			Eventually(verifyControllerUp).Should(Succeed())
+		})
+
+		It("should ensure the metrics endpoint is serving metrics", func() {
+			By("creating a ClusterRoleBinding for the service account to allow access to metrics")
+			// Delete existing ClusterRoleBinding if it exists from previous runs
+			cmd := exec.Command("kubectl", "delete", "clusterrolebinding", metricsRoleBindingName, "--ignore-not-found")
+			_, _ = utils.Run(cmd)
+
+			cmd = exec.Command("kubectl", "create", "clusterrolebinding", metricsRoleBindingName,
+				"--clusterrole=nebari-operator-metrics-reader",
+				fmt.Sprintf("--serviceaccount=%s:%s", namespace, serviceAccountName),
+			)
+			_, err := utils.Run(cmd)
+			Expect(err).NotTo(HaveOccurred(), "Failed to create ClusterRoleBinding")
+
+			By("validating that the metrics service is available")
+			cmd = exec.Command("kubectl", "get", "service", metricsServiceName, "-n", namespace)
+			_, err = utils.Run(cmd)
+			By("getting the service account token")
+			token, err := serviceAccountToken()
+			Expect(err).NotTo(HaveOccurred())
+			Expect(token).NotTo(BeEmpty())
+
+			By("ensuring the controller pod is ready")
+			verifyControllerPodReady := func(g Gomega) {
+				cmd := exec.Command("kubectl", "get", "pod", controllerPodName, "-n", namespace,
+					"-o", "jsonpath={.status.conditions[?(@.type=='Ready')].status}")
+				output, err := utils.Run(cmd)
+				g.Expect(err).NotTo(HaveOccurred())
+				g.Expect(output).To(Equal("True"), "Controller pod not ready")
+			}
+			Eventually(verifyControllerPodReady, 3*time.Minute, time.Second).Should(Succeed())
+
+			By("verifying that the controller manager is serving the metrics server")
+			verifyMetricsServerStarted := func(g Gomega) {
+				cmd := exec.Command("kubectl", "logs", controllerPodName, "-n", namespace)
+				output, err := utils.Run(cmd)
+				g.Expect(err).NotTo(HaveOccurred())
+				g.Expect(output).To(ContainSubstring("Serving metrics server"),
+					"Metrics server not yet started")
+			}
+			Eventually(verifyMetricsServerStarted, 3*time.Minute, time.Second).Should(Succeed())
+
+			// +kubebuilder:scaffold:e2e-metrics-webhooks-readiness
+
+			By("creating the curl-metrics pod to access the metrics endpoint")
+			cmd = exec.Command("kubectl", "run", "curl-metrics", "--restart=Never",
+				"--namespace", namespace,
+				"--image=curlimages/curl:latest",
+				"--overrides",
+				fmt.Sprintf(`{
+					"spec": {
+						"containers": [{
+							"name": "curl",
+							"image": "curlimages/curl:latest",
+							"command": ["/bin/sh", "-c"],
+							"args": ["curl -v -k -H 'Authorization: Bearer %s' https://%s.%s.svc.cluster.local:8443/metrics"],
+							"securityContext": {
+								"readOnlyRootFilesystem": true,
+								"allowPrivilegeEscalation": false,
+								"capabilities": {
+									"drop": ["ALL"]
+								},
+								"runAsNonRoot": true,
+								"runAsUser": 1000,
+								"seccompProfile": {
+									"type": "RuntimeDefault"
+								}
+							}
+						}],
+						"serviceAccountName": "%s"
+					}
+				}`, token, metricsServiceName, namespace, serviceAccountName))
+			_, err = utils.Run(cmd)
+			Expect(err).NotTo(HaveOccurred(), "Failed to create curl-metrics pod")
+
+			By("waiting for the curl-metrics pod to complete.")
+			verifyCurlUp := func(g Gomega) {
+				cmd := exec.Command("kubectl", "get", "pods", "curl-metrics",
+					"-o", "jsonpath={.status.phase}",
+					"-n", namespace)
+				output, err := utils.Run(cmd)
+				g.Expect(err).NotTo(HaveOccurred())
+				g.Expect(output).To(Equal("Succeeded"), "curl pod in wrong status")
+			}
+			Eventually(verifyCurlUp, 5*time.Minute).Should(Succeed())
+
+			By("getting the metrics by checking curl-metrics logs")
+			verifyMetricsAvailable := func(g Gomega) {
+				metricsOutput, err := getMetricsOutput()
+				g.Expect(err).NotTo(HaveOccurred(), "Failed to retrieve logs from curl pod")
+				g.Expect(metricsOutput).NotTo(BeEmpty())
+				g.Expect(metricsOutput).To(ContainSubstring("< HTTP/1.1 200 OK"))
+			}
+			Eventually(verifyMetricsAvailable, 2*time.Minute).Should(Succeed())
+		})
+		// +kubebuilder:scaffold:e2e-webhooks-checks
+	})
+})
diff --git a/test/e2e/nebariapp_test.go b/test/e2e/nebariapp_test.go
new file mode 100644
index 0000000..5a422ac
--- /dev/null
+++ b/test/e2e/nebariapp_test.go
@@ -0,0 +1,279 @@
+//go:build e2e
+// +build e2e
+
+/*
+Copyright 2026, OpenTeams.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package e2e
+
+import (
+	"fmt"
+	"os/exec"
+	"strings"
+	"time"
+
+	. "github.com/onsi/ginkgo/v2"
+	. "github.com/onsi/gomega"
+
+	"github.com/nebari-dev/nebari-operator/test/utils"
+)
+
+var _ = Describe("NebariApp Reconciliation", Ordered, func() {
+	var testNamespace string
+
+	BeforeAll(func() {
+		var cmd *exec.Cmd
+		var err error
+		var output string
+
+		// Check if Gateway API CRDs are installed
+		cmd = exec.Command("kubectl", "get", "crd", "gateways.gateway.networking.k8s.io")
+		_, err = utils.Run(cmd)
+		if err != nil {
+			Skip("Gateway API CRDs not installed - skipping NebariApp tests")
+		}
+
+		By("installing NebariApp CRDs")
+		cmd = exec.Command("make", "install")
+		_, err = utils.Run(cmd)
+		Expect(err).NotTo(HaveOccurred(), "Failed to install CRDs")
+
+		testNamespace = "e2e-test-app"
+
+		By("cleaning up any existing test resources")
+		cmd = exec.Command("kubectl", "get", "nebariapp", "-n", testNamespace, "-o", "name")
+		output, _ = utils.Run(cmd)
+		if output != "" {
+			cmd = exec.Command("kubectl", "delete", "nebariapp", "--all", "-n", testNamespace, "--timeout=60s")
+			_, _ = utils.Run(cmd)
+		}
+		cmd = exec.Command("kubectl", "delete", "namespace", testNamespace, "--ignore-not-found", "--timeout=60s")
+		_, _ = utils.Run(cmd)
+
+		By("waiting for namespace to be fully deleted")
+		Eventually(func() error {
+			cmd = exec.Command("kubectl", "get", "namespace", testNamespace)
+			_, err := utils.Run(cmd)
+			return err // Will return error when namespace doesn't exist
+		}, 2*time.Minute, time.Second).Should(HaveOccurred())
+
+		By("verifying Gateway exists")
+		cmd = exec.Command("kubectl", "get", "gateway", "nebari-gateway", "-n", "envoy-gateway-system")
+		_, err = utils.Run(cmd)
+		Expect(err).NotTo(HaveOccurred(), "Gateway nebari-gateway must exist")
+
+		By("creating test namespace")
+		cmd = exec.Command("kubectl", "create", "namespace", testNamespace)
+		_, err = utils.Run(cmd)
+		Expect(err).NotTo(HaveOccurred(), "Failed to create namespace")
+
+		By("labeling namespace for Operator management")
+		cmd = exec.Command("kubectl", "label", "namespace", testNamespace, "nebari.dev/managed=true")
+		_, err = utils.Run(cmd)
+		Expect(err).NotTo(HaveOccurred(), "Failed to label namespace")
+
+		By("deploying the controller-manager")
+		cmd = exec.Command("make", "deploy", fmt.Sprintf("IMG=%s", projectImage))
+		_, err = utils.Run(cmd)
+		Expect(err).NotTo(HaveOccurred(), "Failed to deploy the controller-manager")
+
+		By("waiting for controller-manager to be ready")
+		Eventually(func(g Gomega) {
+			cmd := exec.Command("kubectl", "get", "deployment", "nebari-operator-controller-manager",
+				"-n", "nebari-operator-system", "-o", "jsonpath={.status.availableReplicas}")
+			output, err := utils.Run(cmd)
+			g.Expect(err).NotTo(HaveOccurred())
+			g.Expect(output).To(Equal("1"))
+		}, 2*time.Minute, time.Second).Should(Succeed())
+
+		By("creating a test application deployment")
+		var appYAML string
+		appYAML, err = utils.LoadTestDataFile("test-app.yaml", map[string]string{
+			"NAMESPACE_PLACEHOLDER": testNamespace,
+		})
+		Expect(err).NotTo(HaveOccurred(), "Failed to load test-app.yaml")
+
+		cmd = exec.Command("kubectl", "apply", "-f", "-")
+		cmd.Stdin = strings.NewReader(appYAML)
+		_, err = utils.Run(cmd)
+		Expect(err).NotTo(HaveOccurred(), "Failed to create test application")
+
+		By("waiting for test application to be ready")
+		Eventually(func(g Gomega) {
+			cmd := exec.Command("kubectl", "get", "deployment", "test-app", "-n", testNamespace,
+				"-o", "jsonpath={.status.availableReplicas}")
+			output, err := utils.Run(cmd)
+			g.Expect(err).NotTo(HaveOccurred())
+			g.Expect(output).To(Equal("1"))
+		}, 2*time.Minute, time.Second).Should(Succeed())
+	})
+
+	AfterAll(func() {
+		By("cleaning up test resources")
+		cmd := exec.Command("kubectl", "delete", "namespace", testNamespace, "--ignore-not-found")
+		_, _ = utils.Run(cmd)
+
+		By("undeploying the controller-manager")
+		cmd = exec.Command("make", "undeploy")
+		_, _ = utils.Run(cmd)
+
+		By("uninstalling CRDs")
+		cmd = exec.Command("make", "uninstall")
+		_, _ = utils.Run(cmd)
+	})
+
+	It("should reconcile a NebariApp resource successfully", func() {
+		By("creating a NebariApp resource")
+		nebariAppYAML, err := utils.LoadTestDataFile("nebariapp.yaml", map[string]string{
+			"NAMESPACE_PLACEHOLDER": testNamespace,
+			"NAME_PLACEHOLDER":      "test-nebariapp",
+			"HOSTNAME_PLACEHOLDER":  "test-app.example.com",
+		})
+		Expect(err).NotTo(HaveOccurred(), "Failed to load nebariapp.yaml")
+
+		cmd := exec.Command("kubectl", "apply", "-f", "-")
+		cmd.Stdin = strings.NewReader(nebariAppYAML)
+		_, err = utils.Run(cmd)
+		Expect(err).NotTo(HaveOccurred(), "Failed to create NebariApp resource")
+
+		By("verifying that the NebariApp resource exists")
+		Eventually(func(g Gomega) {
+			cmd := exec.Command("kubectl", "get", "nebariapp", "test-nebariapp", "-n", testNamespace)
+			_, err := utils.Run(cmd)
+			g.Expect(err).NotTo(HaveOccurred())
+		}, time.Minute, time.Second).Should(Succeed())
+
+		By("verifying that the NebariApp resource is reconciled")
+		Eventually(func(g Gomega) {
+			cmd := exec.Command("kubectl", "get", "nebariapp", "test-nebariapp",
+				"-n", testNamespace,
+				"-o", "jsonpath={.status.conditions[?(@.type=='Ready')].status}")
+			output, err := utils.Run(cmd)
+			g.Expect(err).NotTo(HaveOccurred())
+			g.Expect(output).To(Equal("True"), "NebariApp not ready")
+		}, 3*time.Minute, 5*time.Second).Should(Succeed())
+
+		By("verifying that HTTPRoute was created")
+		Eventually(func(g Gomega) {
+			cmd := exec.Command("kubectl", "get", "httproute", "test-nebariapp-route",
+				"-n", testNamespace, "-o", "jsonpath={.spec.hostnames[0]}")
+			output, err := utils.Run(cmd)
+			g.Expect(err).NotTo(HaveOccurred())
+			g.Expect(output).To(Equal("test-app.example.com"))
+		}, 2*time.Minute, 5*time.Second).Should(Succeed())
+
+		By("verifying HTTPRoute references the correct gateway")
+		cmd = exec.Command("kubectl", "get", "httproute", "test-nebariapp-route",
+			"-n", testNamespace, "-o", "jsonpath={.spec.parentRefs[0].name}")
+		output, err := utils.Run(cmd)
+		Expect(err).NotTo(HaveOccurred())
+		Expect(output).To(Equal("nebari-gateway"))
+
+		By("verifying HTTPRoute references gateway in correct namespace")
+		cmd = exec.Command("kubectl", "get", "httproute", "test-nebariapp-route",
+			"-n", testNamespace, "-o", "jsonpath={.spec.parentRefs[0].namespace}")
+		output, err = utils.Run(cmd)
+		Expect(err).NotTo(HaveOccurred())
+		Expect(output).To(Equal("envoy-gateway-system"))
+
+		By("verifying HTTPRoute backend references correct service")
+		cmd = exec.Command("kubectl", "get", "httproute", "test-nebariapp-route",
+			"-n", testNamespace, "-o", "jsonpath={.spec.rules[0].backendRefs[0].name}")
+		output, err = utils.Run(cmd)
+		Expect(err).NotTo(HaveOccurred())
+		Expect(output).To(Equal("test-app"))
+
+		By("verifying HTTPRoute uses HTTPS listener by default (sectionName=https)")
+		cmd = exec.Command("kubectl", "get", "httproute", "test-nebariapp-route",
+			"-n", testNamespace, "-o", "jsonpath={.spec.parentRefs[0]}")
+		output, err = utils.Run(cmd)
+		Expect(err).NotTo(HaveOccurred())
+		Expect(output).To(ContainSubstring("https"))
+
+		By("verifying RoutingReady condition is True")
+		cmd = exec.Command("kubectl", "get", "nebariapp", "test-nebariapp",
+			"-n", testNamespace, "-o", "jsonpath={.status.conditions[?(@.type=='RoutingReady')].status}")
+		output, err = utils.Run(cmd)
+		Expect(err).NotTo(HaveOccurred())
+		Expect(output).To(Equal("True"))
+	})
+
+	It("should create HTTPRoute with HTTP listener when TLS is disabled", func() {
+		By("creating a NebariApp resource with TLS disabled")
+		nebariAppYAML, err := utils.LoadTestDataFile("nebariapp-tls-disabled.yaml", map[string]string{
+			"NAMESPACE_PLACEHOLDER": testNamespace,
+			"NAME_PLACEHOLDER":      "test-tls-disabled",
+			"HOSTNAME_PLACEHOLDER":  "tls-disabled.example.com",
+		})
+		Expect(err).NotTo(HaveOccurred(), "Failed to load nebariapp-tls-disabled.yaml")
+
+		cmd := exec.Command("kubectl", "apply", "-f", "-")
+		cmd.Stdin = strings.NewReader(nebariAppYAML)
+		_, err = utils.Run(cmd)
+		Expect(err).NotTo(HaveOccurred(), "Failed to create NebariApp resource")
+
+		By("verifying that the NebariApp is reconciled")
+		Eventually(func(g Gomega) {
+			cmd := exec.Command("kubectl", "get", "nebariapp", "test-tls-disabled",
+				"-n", testNamespace,
+				"-o", "jsonpath={.status.conditions[?(@.type=='Ready')].status}")
+			output, err := utils.Run(cmd)
+			g.Expect(err).NotTo(HaveOccurred())
+			g.Expect(output).To(Equal("True"))
+		}, 3*time.Minute, 5*time.Second).Should(Succeed())
+
+		By("verifying HTTPRoute was created")
+		Eventually(func(g Gomega) {
+			cmd := exec.Command("kubectl", "get", "httproute", "test-tls-disabled-route", "-n", testNamespace)
+			_, err := utils.Run(cmd)
+			g.Expect(err).NotTo(HaveOccurred())
+		}, 2*time.Minute, 5*time.Second).Should(Succeed())
+
+		By("verifying HTTPRoute references HTTP listener (sectionName=http)")
+		cmd = exec.Command("kubectl", "get", "httproute", "test-tls-disabled-route",
+			"-n", testNamespace, "-o", "jsonpath={.spec.parentRefs[0]}")
+		output, err := utils.Run(cmd)
+		Expect(err).NotTo(HaveOccurred())
+		Expect(output).To(ContainSubstring("http"))
+		Expect(output).NotTo(ContainSubstring("https"))
+
+		By("verifying HTTPRoute annotation reflects TLS disabled")
+		cmd = exec.Command("kubectl", "get", "httproute", "test-tls-disabled-route",
+			"-n", testNamespace, "-o", "jsonpath={.metadata.annotations}")
+		output, err = utils.Run(cmd)
+		Expect(err).NotTo(HaveOccurred())
+		Expect(output).To(ContainSubstring("nebari.dev/tls-enabled"))
+		Expect(output).To(ContainSubstring("false"))
+
+		By("cleaning up test-tls-disabled resource")
+		cmd = exec.Command("kubectl", "delete", "nebariapp", "test-tls-disabled", "-n", testNamespace, "--ignore-not-found")
+		_, _ = utils.Run(cmd)
+	})
+
+	It("should handle NebariApp deletion and cleanup HTTPRoute", func() {
+		By("deleting the NebariApp resource")
+		cmd := exec.Command("kubectl", "delete", "nebariapp", "test-nebariapp", "-n", testNamespace)
+		_, err := utils.Run(cmd)
+		Expect(err).NotTo(HaveOccurred(), "Failed to delete NebariApp")
+
+		By("verifying HTTPRoute is deleted")
+		Eventually(func() error {
+			cmd := exec.Command("kubectl", "get", "httproute", "test-nebariapp-route", "-n", testNamespace)
+			_, err := utils.Run(cmd)
+			return err // Will return error when HTTPRoute doesn't exist
+		}, 2*time.Minute, 5*time.Second).Should(HaveOccurred())
+	})
+})
diff --git a/test/e2e/testdata/nebariapp-no-routing.yaml b/test/e2e/testdata/nebariapp-no-routing.yaml
new file mode 100644
index 0000000..3425f7f
--- /dev/null
+++ b/test/e2e/testdata/nebariapp-no-routing.yaml
@@ -0,0 +1,11 @@
+apiVersion: reconcilers.nebari.dev/v1
+kind: NebariApp
+metadata:
+  name: NAME_PLACEHOLDER
+  namespace: NAMESPACE_PLACEHOLDER
+spec:
+  hostname: HOSTNAME_PLACEHOLDER
+  gateway: public
+  service:
+    name: test-app
+    port: 80
diff --git a/test/e2e/testdata/nebariapp-tls-disabled.yaml b/test/e2e/testdata/nebariapp-tls-disabled.yaml
new file mode 100644
index 0000000..959e97e
--- /dev/null
+++ b/test/e2e/testdata/nebariapp-tls-disabled.yaml
@@ -0,0 +1,14 @@
+apiVersion: reconcilers.nebari.dev/v1
+kind: NebariApp
+metadata:
+  name: NAME_PLACEHOLDER
+  namespace: NAMESPACE_PLACEHOLDER
+spec:
+  hostname: HOSTNAME_PLACEHOLDER
+  gateway: public
+  service:
+    name: test-app
+    port: 80
+  routing:
+    tls:
+      enabled: false
diff --git a/test/e2e/testdata/nebariapp.yaml b/test/e2e/testdata/nebariapp.yaml
index 264504d..b654ed8 100644
--- a/test/e2e/testdata/nebariapp.yaml
+++ b/test/e2e/testdata/nebariapp.yaml
@@ -4,7 +4,9 @@ metadata:
   name: NAME_PLACEHOLDER
   namespace: NAMESPACE_PLACEHOLDER
 spec:
-  hostname: test-app.example.com
+  hostname: HOSTNAME_PLACEHOLDER
+  gateway: public
   service:
     name: test-app
     port: 80
+  routing: {}
diff --git a/test/utils/utils.go b/test/utils/utils.go
index 34bc4a5..ba52050 100644
--- a/test/utils/utils.go
+++ b/test/utils/utils.go
@@ -22,23 +22,17 @@ import (
 	"fmt"
 	"os"
 	"os/exec"
+	"sort"
 	"strings"
 
 	. "github.com/onsi/ginkgo/v2" // nolint:revive,staticcheck
 )
 
 const (
-	certmanagerVersion = "v1.19.1"
-	certmanagerURLTmpl = "https://github.com/cert-manager/cert-manager/releases/download/%s/cert-manager.yaml"
-
 	defaultKindBinary  = "kind"
 	defaultKindCluster = "kind"
 )
 
-func warnError(err error) {
-	_, _ = fmt.Fprintf(GinkgoWriter, "warning: %v\n", err)
-}
-
 // Run executes the provided command within this context
 func Run(cmd *exec.Cmd) (string, error) {
 	dir, _ := GetProjectDir()
@@ -59,78 +53,32 @@ func Run(cmd *exec.Cmd) (string, error) {
 	return string(output), nil
 }
 
-// UninstallCertManager uninstalls the cert manager
-func UninstallCertManager() {
-	url := fmt.Sprintf(certmanagerURLTmpl, certmanagerVersion)
-	cmd := exec.Command("kubectl", "delete", "-f", url)
-	if _, err := Run(cmd); err != nil {
-		warnError(err)
-	}
-
-	// Delete leftover leases in kube-system (not cleaned by default)
-	kubeSystemLeases := []string{
-		"cert-manager-cainjector-leader-election",
-		"cert-manager-controller",
-	}
-	for _, lease := range kubeSystemLeases {
-		cmd = exec.Command("kubectl", "delete", "lease", lease,
-			"-n", "kube-system", "--ignore-not-found", "--force", "--grace-period=0")
-		if _, err := Run(cmd); err != nil {
-			warnError(err)
-		}
-	}
+// IsCertManagerInstalled checks if cert-manager is installed by checking for its CRDs.
+func IsCertManagerInstalled() bool {
+	cmd := exec.Command("kubectl", "get", "crd", "certificates.cert-manager.io")
+	_, err := Run(cmd)
+	return err == nil
 }
 
-// InstallCertManager installs the cert manager bundle.
-func InstallCertManager() error {
-	url := fmt.Sprintf(certmanagerURLTmpl, certmanagerVersion)
-	cmd := exec.Command("kubectl", "apply", "-f", url)
-	if _, err := Run(cmd); err != nil {
-		return err
-	}
-	// Wait for cert-manager-webhook to be ready, which can take time if cert-manager
-	// was re-installed after uninstalling on a cluster.
-	cmd = exec.Command("kubectl", "wait", "deployment.apps/cert-manager-webhook",
-		"--for", "condition=Available",
-		"--namespace", "cert-manager",
-		"--timeout", "5m",
-	)
-
+// IsEnvoyGatewayInstalled checks if Envoy Gateway is installed.
+func IsEnvoyGatewayInstalled() bool {
+	cmd := exec.Command("kubectl", "get", "deployment", "envoy-gateway", "-n", "envoy-gateway-system")
 	_, err := Run(cmd)
-	return err
+	return err == nil
 }
 
-// IsCertManagerCRDsInstalled checks if any Cert Manager CRDs are installed
-// by verifying the existence of key CRDs related to Cert Manager.
-func IsCertManagerCRDsInstalled() bool {
-	// List of common Cert Manager CRDs
-	certManagerCRDs := []string{
-		"certificates.cert-manager.io",
-		"issuers.cert-manager.io",
-		"clusterissuers.cert-manager.io",
-		"certificaterequests.cert-manager.io",
-		"orders.acme.cert-manager.io",
-		"challenges.acme.cert-manager.io",
-	}
-
-	// Execute the kubectl command to get all CRDs
-	cmd := exec.Command("kubectl", "get", "crds")
-	output, err := Run(cmd)
-	if err != nil {
-		return false
-	}
-
-	// Check if any of the Cert Manager CRDs are present
-	crdList := GetNonEmptyLines(output)
-	for _, crd := range certManagerCRDs {
-		for _, line := range crdList {
-			if strings.Contains(line, crd) {
-				return true
-			}
-		}
-	}
+// IsGatewayAPIInstalled checks if Gateway API CRDs are installed.
+func IsGatewayAPIInstalled() bool {
+	cmd := exec.Command("kubectl", "get", "crd", "gateways.gateway.networking.k8s.io")
+	_, err := Run(cmd)
+	return err == nil
+}
 
-	return false
+// IsGatewayReady checks if the nebari-gateway exists and is ready.
+func IsGatewayReady() bool {
+	cmd := exec.Command("kubectl", "get", "gateway", "nebari-gateway", "-n", "envoy-gateway-system")
+	_, err := Run(cmd)
+	return err == nil
 }
 
 // CreateKindCluster creates a kind cluster with the given name
@@ -298,8 +246,19 @@ func LoadTestDataFile(filename string, replacements map[string]string) (string,
 	}
 
 	result := string(content)
-	for placeholder, value := range replacements {
-		result = strings.ReplaceAll(result, placeholder, value)
+
+	// Sort placeholders by length (descending) to avoid partial replacements
+	// e.g., replace "HOSTNAME_PLACEHOLDER" before "NAME_PLACEHOLDER"
+	placeholders := make([]string, 0, len(replacements))
+	for placeholder := range replacements {
+		placeholders = append(placeholders, placeholder)
+	}
+	sort.Slice(placeholders, func(i, j int) bool {
+		return len(placeholders[i]) > len(placeholders[j])
+	})
+
+	for _, placeholder := range placeholders {
+		result = strings.ReplaceAll(result, placeholder, replacements[placeholder])
 	}
 
 	return result, nil
